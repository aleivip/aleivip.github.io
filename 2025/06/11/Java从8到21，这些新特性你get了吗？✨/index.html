<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java从8到21，这些新特性你get了吗？✨ | 指尖留痕</title><meta name="author" content="啊雷,528301299@qq.com"><meta name="copyright" content="啊雷"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JDK 8：开启函数式编程大门 添加图片注释，不超过 140 字（可选） JDK 8 于 2014 年 3 月发布，是 Java 发展历程中的一个重要里程碑  它带来了诸多创新特性，其中最引人注目的当属 Lambda 表达式、Stream API 和 Optional 类。这些特性不仅简化了代码编写，还提升了 Java 的编程效率和表达能力。 Lambda 表达式Lambda 表达式允许将代码块作">
<meta property="og:type" content="article">
<meta property="og:title" content="Java从8到21，这些新特性你get了吗？✨">
<meta property="og:url" content="http://alei.vip/2025/06/11/Java%E4%BB%8E8%E5%88%B021%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%A0get%E4%BA%86%E5%90%97%EF%BC%9F%E2%9C%A8/index.html">
<meta property="og:site_name" content="指尖留痕">
<meta property="og:description" content="JDK 8：开启函数式编程大门 添加图片注释，不超过 140 字（可选） JDK 8 于 2014 年 3 月发布，是 Java 发展历程中的一个重要里程碑  它带来了诸多创新特性，其中最引人注目的当属 Lambda 表达式、Stream API 和 Optional 类。这些特性不仅简化了代码编写，还提升了 Java 的编程效率和表达能力。 Lambda 表达式Lambda 表达式允许将代码块作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://alei.vip/images/post_img/cover.png">
<meta property="article:published_time" content="2025-06-11T01:06:18.000Z">
<meta property="article:modified_time" content="2025-06-11T05:14:20.523Z">
<meta property="article:author" content="啊雷">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="JDK">
<meta property="article:tag" content="新特性">
<meta property="article:tag" content=" JDK8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://alei.vip/images/post_img/cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java从8到21，这些新特性你get了吗？✨",
  "url": "http://alei.vip/2025/06/11/Java%E4%BB%8E8%E5%88%B021%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%A0get%E4%BA%86%E5%90%97%EF%BC%9F%E2%9C%A8/",
  "image": "http://alei.vip/images/post_img/cover.png",
  "datePublished": "2025-06-11T01:06:18.000Z",
  "dateModified": "2025-06-11T05:14:20.523Z",
  "author": [
    {
      "@type": "Person",
      "name": "啊雷",
      "url": "http://alei.vip/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://alei.vip/2025/06/11/Java%E4%BB%8E8%E5%88%B021%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%A0get%E4%BA%86%E5%90%97%EF%BC%9F%E2%9C%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"2WLZSTDSU1","apiKey":"0b77e0056aaee18d22ae30a6e9a52040","indexName":"hexo","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java从8到21，这些新特性你get了吗？✨',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4945836_p2w0pg38zwf.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-home"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于啊雷</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/post_img/cover.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">指尖留痕</span></a><a class="nav-page-title" href="/"><span class="site-name">Java从8到21，这些新特性你get了吗？✨</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-home"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 更多</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于啊雷</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java从8到21，这些新特性你get了吗？✨</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-11T01:06:18.000Z" title="发表于 2025-06-11 09:06:18">2025-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-11T05:14:20.523Z" title="更新于 2025-06-11 13:14:20">2025-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">28.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>104分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="JDK-8：开启函数式编程大门"><a href="#JDK-8：开启函数式编程大门" class="headerlink" title="JDK 8：开启函数式编程大门"></a>JDK 8：开启函数式编程大门</h2><p><img src="https://pic1.zhimg.com/80/v2-2430e6015374c350857214cfbcefccbf_1440w.png?source=d16d100b"></p>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>JDK 8 于 2014 年 3 月发布，是 Java 发展历程中的一个重要里程碑  它带来了诸多创新特性，其中最引人注目的当属 Lambda 表达式、Stream API 和 Optional 类。这些特性不仅简化了代码编写，还提升了 Java 的编程效率和表达能力。</p>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式允许将代码块作为方法参数传递，从而使代码更加简洁和灵活。它的基本语法是：(parameters) -&gt; expression 或 (parameters) -&gt; { statements; }。例如，使用 Lambda 表达式实现一个简单的 Runnable 接口：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 使用匿名内部类实现Runnable接口

new Thread(new Runnable() &#123;

       @Override

       public void run() &#123;

           System.out.println(&quot;Before Java 8, too much code for too little to do&quot;);

       &#125;

&#125;).start();

&#x2F;&#x2F; 使用Lambda表达式实现Runnable接口

new Thread(() -&gt; System.out.println(&quot;In Java 8, Lambda expression rocks !!&quot;)).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，Lambda 表达式 () -&gt; System.out.println(“In Java 8, Lambda expression rocks !!”) 简洁地替代了匿名内部类的繁琐写法，使代码更加清晰易读。</p>
<h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>Stream API 提供了一种高效且声明式的方式来处理集合数据。它允许通过一系列中间操作（如过滤、映射、排序等）和终端操作（如收集、归约等）对数据进行处理。例如，使用 Stream API 对列表进行过滤和映射操作：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.Arrays;

import java.util.List;

import java.util.stream.Collectors;

public class StreamExample &#123;

       public static void main(String\[] args) &#123;

           List\&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

           &#x2F;&#x2F; 使用Stream API过滤出偶数并将其平方

           List\&lt;Integer&gt; result &#x3D; numbers.stream()

                                         .filter(n -&gt; n % 2 &#x3D;&#x3D; 0)

                                         .map(n -&gt; n \* n)

                                         .collect(Collectors.toList());

           System.out.println(result); &#x2F;&#x2F; 输出: \[4, 16, 36, 64, 100]

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过 Stream API，我们可以以一种声明式的方式表达数据处理逻辑，而无需编写繁琐的循环和条件语句，大大提高了代码的可读性和可维护性。</p>
<h3 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h3><p>Optional 类是为了解决空指针异常（NullPointerException）而引入的。它提供了一种更安全的方式来处理可能为 null 的值。例如，使用 Optional 类来获取对象的属性，避免空指针异常：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.Optional;

public class OptionalExample &#123;

       public static void main(String\[] args) &#123;

           &#x2F;&#x2F; 假设我们有一个可能为null的字符串

           String name &#x3D; null;

           &#x2F;&#x2F; 使用Optional类来处理空指针异常

           Optional\&lt;String&gt; optionalName &#x3D; Optional.ofNullable(name);

           String result &#x3D; optionalName.orElse(&quot;Unknown&quot;);

           System.out.println(result); &#x2F;&#x2F; 输出: Unknown

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，Optional.ofNullable(name) 创建了一个 Optional 对象，如果 name 为 null，optionalName.orElse(“Unknown”) 会返回默认值 “Unknown”，从而避免了空指针异常的发生。</p>
<p>JDK 8 的这些新特性为 Java 开发者带来了更强大的工具和更简洁的编程体验，使 Java 在现代软件开发中保持了竞争力。无论是处理集合数据、避免空指针异常还是实现更灵活的代码结构，JDK 8 都提供了优雅的解决方案</p>
<hr>
<h2 id="JDK-9-模块化与更多改进"><a href="#JDK-9-模块化与更多改进" class="headerlink" title="JDK 9 - 模块化与更多改进"></a>JDK 9 - 模块化与更多改进</h2><p><img src="https://picx.zhimg.com/80/v2-c76d1a66db6a39eea56ca582a5209c7c_1440w.png?source=d16d100b"></p>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>JDK 9 于 2017 年 9 月发布，它引入了期待已久的模块化系统，为 Java 平台带来了更强大的封装和依赖管理能力，开启了 Java 平台模块化时代，让 Java 应用的结构更加清晰、可维护性更强。同时，JDK 9 还带来了许多其他的改进和新特性，如私有接口方法、集合工厂方法、JShell 等，为开发者提供了更丰富的工具和更高效的开发体验。</p>
<h3 id="模块化系统（Project-Jigsaw）"><a href="#模块化系统（Project-Jigsaw）" class="headerlink" title="模块化系统（Project Jigsaw）"></a>模块化系统（Project Jigsaw）</h3><p>JDK 9 的模块化系统允许将 Java 应用分解为独立的模块，每个模块都有自己的依赖和导出的接口。这有助于提高代码的可维护性、安全性和可重用性。</p>
<p>在模块化系统中，使用module-info.java文件来定义模块的边界和依赖关系。例如，定义一个简单的模块：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; module-info.java

module com.example.myapp &#123;

       requires java.base;

       exports com.example.myapp.publicapi;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码定义了一个名为com.example.myapp的模块，它依赖于java.base模块，并导出com.example.myapp.publicapi包，以便其他模块可以访问。</p>
<h3 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h3><p>从 JDK 9 开始，接口中可以定义私有方法，这有助于在接口中封装一些通用的实现逻辑，避免代码重复。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">public interface MyInterface &#123;

       void publicMethod();

       default void defaultMethod() &#123;

           privateMethod();

           System.out.println(&quot;This is a default method.&quot;);

       &#125;

       private void privateMethod() &#123;

           System.out.println(&quot;This is a private method.&quot;);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述接口中，privateMethod是一个私有方法，只能在接口内部被调用，defaultMethod通过调用privateMethod来实现一些通用的逻辑。</p>
<h3 id="集合工厂方法"><a href="#集合工厂方法" class="headerlink" title="集合工厂方法"></a>集合工厂方法</h3><p>JDK 9 为集合类引入了新的工厂方法，使得创建不可变集合更加简洁。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.List;

import java.util.Set;

import java.util.Map;

public class CollectionFactoryMethodsExample &#123;

       public static void main(String\[] args) &#123;

           &#x2F;&#x2F; 创建不可变列表

           List\&lt;String&gt; immutableList &#x3D; List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C++&quot;);

           System.out.println(&quot;Immutable List: &quot; + immutableList);

           &#x2F;&#x2F; 创建不可变集合

           Set\&lt;String&gt; immutableSet &#x3D; Set.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C++&quot;);

           System.out.println(&quot;Immutable Set: &quot; + immutableSet);

           &#x2F;&#x2F; 创建不可变映射

           Map\&lt;String, Integer&gt; immutableMap &#x3D; Map.of(&quot;Java&quot;, 10, &quot;Python&quot;, 20, &quot;C++&quot;, 30);

           System.out.println(&quot;Immutable Map: &quot; + immutableMap);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过List.of、Set.of和Map.of方法，可以快速创建不可变的列表、集合和映射，并且这些集合一旦创建就不能被修改，保证了数据的不可变性。</p>
<h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>JShell 是一个交互式的命令行工具，允许用户直接执行 Java 代码片段并立即看到结果，非常适合快速测试和学习 Java。例如，启动 JShell 后，可以直接执行以下代码：</p>
<pre class="line-numbers language-none"><code class="language-none">jshell&gt; int num &#x3D; 5;

num &#x3D;&#x3D;&gt; 5

jshell&gt; int square &#x3D; num \* num;

square &#x3D;&#x3D;&gt; 25

jshell&gt; System.out.println(square);

25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 JShell 中，可以方便地进行变量声明、表达式计算和方法调用等操作，无需编写完整的 Java 类和main方法，大大提高了开发效率和学习体验。</p>
<p>JDK 9 的这些新特性为 Java 开发者带来了更强大的功能和更便捷的开发方式，尤其是模块化系统的引入，为大型 Java 项目的开发和维护提供了更好的支持。无论是优化代码结构、提高开发效率还是增强代码的安全性，JDK 9 都迈出了重要的一步</p>
<hr>
<h2 id="JDK-10-局部变量类型推断来袭"><a href="#JDK-10-局部变量类型推断来袭" class="headerlink" title="JDK 10 - 局部变量类型推断来袭"></a>JDK 10 - 局部变量类型推断来袭</h2><p><img src="https://picx.zhimg.com/80/v2-19d4d0b0d489791c86b993329c675926_1440w.png?source=d16d100b"></p>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>JDK 10 于 2018 年 3 月发布，带来了 12 个新特性，其中最引人注目的是局部变量类型推断，通过var关键字来实现。这一特性旨在简化代码编写，减少冗余的类型声明，让代码更加简洁易读，同时保持 Java 的编译时类型检查。</p>
<h3 id="什么是局部变量类型推断"><a href="#什么是局部变量类型推断" class="headerlink" title="什么是局部变量类型推断"></a>什么是局部变量类型推断</h3><p>在 JDK 10 之前，声明局部变量时需要显式指定变量的类型，例如：</p>
<pre class="line-numbers language-none"><code class="language-none">List\&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>而在 JDK 10 中，可以使用var关键字来声明局部变量，编译器会根据变量的初始化值自动推断其类型：</p>
<pre class="line-numbers language-none"><code class="language-none">var list &#x3D; new ArrayList\&lt;String&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里，编译器会根据右侧new ArrayList<String>()表达式，推断出list的类型为ArrayList<String>。</p>
<h3 id="var关键字的使用示例"><a href="#var关键字的使用示例" class="headerlink" title="var关键字的使用示例"></a>var关键字的使用示例</h3><p>字面量初始化：</p>
<pre class="line-numbers language-none"><code class="language-none">var name &#x3D; &quot;Java&quot;;

var age &#x3D; 18;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在这两个例子中，编译器分别推断name的类型为String，age的类型为int。</p>
<p>方法返回值：</p>
<pre class="line-numbers language-none"><code class="language-none">public static String getMessage() &#123;

       return &quot;Hello, Java 10!&quot;;

&#125;

public static void main(String\[] args) &#123;

       var message &#x3D; getMessage();

       System.out.println(message);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>message的类型会被推断为String，因为getMessage方法返回的是String类型。</p>
<p>循环变量：</p>
<pre class="line-numbers language-none"><code class="language-none">for (var i &#x3D; 0; i &lt; 10; i++) &#123;

       System.out.println(i);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里i的类型被推断为int。</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>虽然var关键字带来了代码的简洁性，但它也有一些局限性：</p>
<p>必须初始化：使用var声明变量时，必须同时进行初始化，因为编译器需要根据初始化值来推断变量的类型。例如，以下代码会编译错误：</p>
<pre class="line-numbers language-none"><code class="language-none">var num; &#x2F;&#x2F; 编译错误，必须初始化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>只能用于局部变量：var不能用于类的成员变量、方法参数或返回类型。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">public class VarLimitations &#123;

       var memberVariable &#x3D; &quot;成员变量不能使用var&quot;; &#x2F;&#x2F; 编译错误

       public void method(var param) &#123; &#x2F;&#x2F; 编译错误

           &#x2F;&#x2F; 方法体

       &#125;

       public static var getResult() &#123; &#x2F;&#x2F; 编译错误

           return &quot;方法返回类型不能使用var&quot;;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不能用于null初始化：不能使用var声明一个初始化为null的变量，因为编译器无法推断其类型。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">var obj &#x3D; null; &#x2F;&#x2F; 编译错误<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复杂表达式中可能降低可读性：在一些复杂的表达式中，过度使用var可能会使代码的可读性变差，因为读者需要花费更多的时间去推断变量的类型。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">var result &#x3D; someComplexMethodThatReturnsAComplexType();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在这种情况下，使用具体的类型声明可能会使代码更易理解。</p>
<h3 id="在实际代码中的应用"><a href="#在实际代码中的应用" class="headerlink" title="在实际代码中的应用"></a>在实际代码中的应用</h3><p>在实际开发中，当类型名称过长或过于复杂时，使用var关键字可以显著简化代码。例如，使用CopyOnWriteArrayList时：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 传统方式

CopyOnWriteArrayList\&lt;String&gt; list1 &#x3D; new CopyOnWriteArrayList&lt;&gt;();

&#x2F;&#x2F; 使用var关键字

var list2 &#x3D; new CopyOnWriteArrayList\&lt;String&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，使用var关键字后，代码更加简洁，同时保持了类型安全。因为在编译时，list2的类型仍然是CopyOnWriteArrayList<String>，编译器会进行严格的类型检查。</p>
<p>JDK 10 的局部变量类型推断是一个实用的特性，它在一定程度上提高了代码的编写效率和可读性，但开发者需要在简洁性和代码可读性之间找到平衡，合理使用var关键字。</p>
<hr>
<h2 id="JDK-11-增强与优化"><a href="#JDK-11-增强与优化" class="headerlink" title="JDK 11 - 增强与优化"></a>JDK 11 - 增强与优化</h2><p><img src="https://picx.zhimg.com/80/v2-0965f0208b95e1f51218e211d5c795fd_1440w.png?source=d16d100b"></p>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>JDK 11 于 2018 年 9 月发布，作为长期支持（LTS）版本，带来了诸多实用的增强与优化，进一步提升了 Java 的性能和开发体验。</p>
<h3 id="HTTP-2-客户端"><a href="#HTTP-2-客户端" class="headerlink" title="HTTP&#x2F;2 客户端"></a>HTTP&#x2F;2 客户端</h3><p>JDK 11 将 JDK 9 引入并孵化的 HTTP 客户端 API 标准化，提供了更现代、灵活且功能强大的 HTTP 客户端，支持 HTTP&#x2F;2 和 WebSocket 协议，替代了老旧的HttpURLConnection。它不仅支持同步和异步请求，还具备连接池、代理、Cookie 管理、重定向等功能。</p>
<pre class="line-numbers language-none"><code class="language-none">import java.net.URI;

import java.net.http.HttpClient;

import java.net.http.HttpRequest;

import java.net.http.HttpResponse;

public class HttpClientExample &#123;

       public static void main(String\[] args) throws Exception &#123;

           &#x2F;&#x2F; 创建HttpClient对象

           HttpClient client &#x3D; HttpClient.newHttpClient();

           &#x2F;&#x2F; 创建HttpRequest请求

           HttpRequest request &#x3D; HttpRequest.newBuilder()

                                          .uri(URI.create(&quot;https:&#x2F;&#x2F;www.example.com&quot;))

                                          .GET()

                                          .build();

           &#x2F;&#x2F; 发送请求并获取响应

           HttpResponse\&lt;String&gt; response &#x3D; client.send(request, HttpResponse.BodyHandlers.ofString());

           &#x2F;&#x2F; 输出响应状态码和响应体

           System.out.println(&quot;Response Code: &quot; + response.statusCode());

           System.out.println(&quot;Response Body: &quot; + response.body());

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过HttpClient发送 GET 请求，获取并打印目标网站的响应状态码和响应体，展示了新 HTTP 客户端的基本用法。</p>
<h3 id="字符串-API-增强"><a href="#字符串-API-增强" class="headerlink" title="字符串 API 增强"></a>字符串 API 增强</h3><p>JDK 11 为字符串类新增了多个实用方法，使得字符串处理更加便捷。</p>
<p>isBlank()：判断字符串是否为空或仅包含空白字符。</p>
<p>strip()：去除字符串两端的空白字符，包括全角和半角空格。</p>
<p>repeat(int count)：重复字符串指定次数。</p>
<p>lines()：将字符串按行分割成Stream<String>。</p>
<pre class="line-numbers language-none"><code class="language-none">public class StringApiEnhancementExample &#123;

       public static void main(String\[] args) &#123;

           String blankStr &#x3D; &quot;   &quot;;

           System.out.println(blankStr.isBlank()); &#x2F;&#x2F; true

           String strWithSpace &#x3D; &quot;  Java 11  &quot;;

           System.out.println(strWithSpace.strip()); &#x2F;&#x2F; &quot;Java 11&quot;

           String repeatedStr &#x3D; &quot;Hello &quot;.repeat(3);

           System.out.println(repeatedStr); &#x2F;&#x2F; &quot;Hello Hello Hello &quot;

           String multiLineStr &#x3D; &quot;Line1\nLine2\nLine3&quot;;

           multiLineStr.lines().forEach(System.out::println);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码分别演示了这些新方法的使用，isBlank用于判断字符串是否空白，strip去除字符串两端空格，repeat重复字符串，lines按行分割字符串并遍历输出。</p>
<h3 id="Epsilon-和-ZGC-垃圾收集器"><a href="#Epsilon-和-ZGC-垃圾收集器" class="headerlink" title="Epsilon 和 ZGC 垃圾收集器"></a>Epsilon 和 ZGC 垃圾收集器</h3><p>Epsilon 垃圾收集器：也被称为无操作垃圾收集器，它只负责内存分配，不执行任何实际的垃圾回收工作。当堆内存耗尽时，JVM 会直接退出。主要用于性能测试、内存压力测试、非常短的任务以及 VM 接口测试等场景。通过-XX:+UseEpsilonGC参数启用。</p>
<p>ZGC 垃圾收集器（实验性）：这是一个可扩展的低延迟垃圾收集器，目标是实现亚毫秒级的最大停顿时间，并且停顿时间不会随着堆、存活对象集或根对象集的大小而增加，适用于大内存堆（从 8MB 到 16TB）的场景。它采用了并发标记 - 整理算法，通过染色指针、读屏障和基于 Region 的内存布局等技术来实现高效的垃圾回收。使用-XX:+UseZGC参数启用。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 此代码用于测试垃圾收集器，通过不断创建对象来消耗内存

public class GCTest &#123;

       public static void main(String\[] args) &#123;

           List\&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();

           while (true) &#123;

               list.add(new Object());

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码是一个简单的测试垃圾收集器的示例，通过不断创建对象来消耗内存，结合不同的垃圾收集器参数（如-XX:+UseEpsilonGC或-XX:+UseZGC）运行，可以观察不同垃圾收集器的行为和特点。</p>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p>局部变量语法增强：在 JDK 10 局部变量类型推断（var）的基础上，JDK 11 允许在 Lambda 表达式的参数中使用var，使代码更加简洁。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">List\&lt;String&gt; names &#x3D; List.of(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);

names.forEach((var name) -&gt; System.out.println(&quot;Hello, &quot; + name));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>启动单个 Java 源代码文件：可以直接运行单文件源码程序，无需先进行编译。例如，有一个HelloWorld.java文件：</p>
<pre class="line-numbers language-none"><code class="language-none">public class HelloWorld &#123;

       public static void main(String\[] args) &#123;

           System.out.println(&quot;Hello, World!&quot;);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在命令行中直接运行java HelloWorld.java即可输出结果，简化了快速测试和小型项目的开发流程。</p>
<p>JDK 11 的这些新特性和优化，无论是在网络编程、字符串处理还是垃圾回收等方面，都为开发者提供了更强大、更便捷的工具，有助于提升 Java 应用的性能和开发效率 。</p>
<hr>
<h2 id="JDK-12"><a href="#JDK-12" class="headerlink" title="JDK 12"></a>JDK 12</h2><p><img src="https://pica.zhimg.com/80/v2-255d9739828e50f002a0d439d6371092_1440w.png?source=d16d100b"></p>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>JDK 12 在 2019 年 3 月发布，虽然不是 LTS 版本，但也带来了一些值得关注的特性，进一步推动了 Java 语言的发展和改进。</p>
<h3 id="Switch-表达式改进（预览）"><a href="#Switch-表达式改进（预览）" class="headerlink" title="Switch 表达式改进（预览）"></a>Switch 表达式改进（预览）</h3><p>JDK 12 对switch语句进行了重大改进，使其可以作为表达式使用，并且支持更简洁的语法。在传统的switch语句中，每个case分支都需要使用break语句来防止穿透，代码较为繁琐。而在 JDK 12 中，引入了新的语法case … -&gt;，简化了switch语句的编写。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; JDK 12之前的switch语句

int num &#x3D; 1;

String resultBefore;

switch (num) &#123;

       case 1:

           resultBefore &#x3D; &quot;One&quot;;

           break;

       case 2:

           resultBefore &#x3D; &quot;Two&quot;;

           break;

       default:

           resultBefore &#x3D; &quot;Other&quot;;

           break;

&#125;

&#x2F;&#x2F; JDK 12的switch表达式

int num1 &#x3D; 1;

String resultAfter &#x3D; switch (num1) &#123;

       case 1 -&gt; &quot;One&quot;;

       case 2 -&gt; &quot;Two&quot;;

       default -&gt; &quot;Other&quot;;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，JDK 12 的switch表达式不仅省略了break语句，还可以直接将表达式的结果赋值给变量，使代码更加简洁易读。需要注意的是，在 JDK 12 中，switch表达式是一个预览特性，使用时需要添加–enable-preview参数。</p>
<h3 id="JVM-常量-API"><a href="#JVM-常量-API" class="headerlink" title="JVM 常量 API"></a>JVM 常量 API</h3><p>JDK 12 引入了 JVM 常量 API，在java.lang.invoke.constant包中定义了一系列基于值的符号引用类型，用于描述各种可加载常量。这使得处理类文件的程序能够更方便地操作可加载常量，尤其是那些从常量池中加载的常量。</p>
<pre class="line-numbers language-none"><code class="language-none">import java.lang.invoke.ConstantCallSite;

import java.lang.invoke.MethodHandles;

import java.lang.invoke.constant.ClassDesc;

import java.lang.invoke.constant.MethodTypeDesc;

public class JvmConstantsApiExample &#123;

       public static void main(String\[] args) throws Throwable &#123;

           &#x2F;&#x2F; 获取String类的ClassDesc

           ClassDesc stringClassDesc &#x3D; ClassDesc.of(String.class);

           &#x2F;&#x2F; 获取String类的length方法的MethodTypeDesc

           MethodTypeDesc lengthMethodType &#x3D; MethodTypeDesc.of(int.class);

           &#x2F;&#x2F; 创建一个常量调用站点，用于调用String的length方法

           ConstantCallSite callSite &#x3D; new ConstantCallSite(

                   MethodHandles.lookup().findVirtual(stringClassDesc, &quot;length&quot;, lengthMethodType));

           &#x2F;&#x2F; 调用length方法

           String str &#x3D; &quot;Hello, Java 12&quot;;

           int length &#x3D; (int) callSite.getTarget().invoke(str);

           System.out.println(&quot;Length of the string: &quot; + length);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码展示了如何使用 JVM 常量 API 来获取类的描述和方法的描述，并通过常量调用站点来调用方法。这在处理字节码指令和可加载常量时非常有用，可以更灵活地操作类和方法。</p>
<h3 id="Shenandoah-垃圾收集器（实验性）"><a href="#Shenandoah-垃圾收集器（实验性）" class="headerlink" title="Shenandoah 垃圾收集器（实验性）"></a>Shenandoah 垃圾收集器（实验性）</h3><p>Shenandoah 是一个低停顿时间的垃圾收集器，在 JDK 12 中作为实验性特性引入。它通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间，并且暂停时间与堆大小无关。这使得它非常适合高吞吐和大内存场景。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 使用Shenandoah垃圾收集器

&#x2F;&#x2F; 在启动JVM时添加参数：-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC

public class ShenandoahGCExample &#123;

       public static void main(String\[] args) &#123;

           List\&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();

           while (true) &#123;

               list.add(new Object());

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在实际使用中，通过在启动 JVM 时添加-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC参数来启用 Shenandoah 垃圾收集器。它的设计目标是实现响应性和一致可控的短暂停顿，通过为每个 Java 对象添加一个间接指针，使得 GC 线程能够在 Java 线程运行时压缩堆，标记和压缩同时执行，只需要暂停 Java 线程在一致可控的时间内扫描线程堆栈以查找和更新对象图的根 。</p>
<hr>
<h2 id="JDK-13"><a href="#JDK-13" class="headerlink" title="JDK 13"></a>JDK 13</h2><p><img src="https://picx.zhimg.com/80/v2-f2c5363cd60c2a719182c89caff11bfc_1440w.png?source=d16d100b"></p>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>JDK 13 在 2019 年 9 月发布，虽然不是长期支持版本，但也带来了一些实用的新特性和改进，为 Java 开发者提供了更多的选择和优化方案。</p>
<h3 id="动态的-CDS-归档文件"><a href="#动态的-CDS-归档文件" class="headerlink" title="动态的 CDS 归档文件"></a>动态的 CDS 归档文件</h3><p>JDK 13 引入了动态的 Class Data Sharing（CDS）归档文件，旨在提高 Java 应用程序的启动性能。它允许多个 Java 进程共享相同的已经被预先加载和编译的类数据，从而减少启动时间和内存占用。在一些大型企业级应用中，多个 Java 进程可能需要加载相同的基础类库，使用动态 CDS 归档文件后，这些类库只需加载一次，就可以在多个进程间共享，大大提高了应用的启动速度和内存利用率。</p>
<pre class="line-numbers language-none"><code class="language-none">\# 生成共享归档文件

java -Xshare:dump -XX:SharedClassListFile&#x3D;myapp.lst -XX:SharedArchiveFile&#x3D;myapp.jsa -cp myapp.jar

\# 使用共享归档文件运行应用

java -Xshare:on -XX:SharedArchiveFile&#x3D;myapp.jsa -cp myapp.jar MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述命令中，-Xshare:dump用于启用类共享并生成共享归档文件，-XX:SharedClassListFile指定包含要共享类的列表文件，-XX:SharedArchiveFile指定生成的共享归档文件的名称；-Xshare:on表示启用类共享，使用先前生成的共享归档文件。</p>
<h3 id="改进了-ZGC"><a href="#改进了-ZGC" class="headerlink" title="改进了 ZGC"></a>改进了 ZGC</h3><p>JDK 13 对 ZGC 进行了改进，允许操作系统返回不再使用的 Java 堆内存。在一些内存敏感的应用场景中，如容器环境下的应用，ZGC 的这一改进可以有效减少内存占用，提高资源利用率，使得应用在有限的内存资源下能够更稳定地运行。</p>
<pre class="line-numbers language-none"><code class="language-none">\# 使用ZGC并设置最大堆内存为4GB

java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx4g MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过添加-XX:+UnlockExperimentalVMOptions -XX:+UseZGC参数来启用 ZGC，-Xmx4g设置最大堆内存为 4GB。</p>
<h3 id="重新实现了-Socket-API"><a href="#重新实现了-Socket-API" class="headerlink" title="重新实现了 Socket API"></a>重新实现了 Socket API</h3><p>JDK 13 重新实现了传统的 Socket API，以提供更好的性能和可维护性。新的实现更易于维护和调试，直接使用 JDK 的 NIO 实现，不需要自己的本地代码，并且结合了 buffer cache 机制，避免了使用线程栈进行 IO 操作。在网络编程中，新的 Socket API 可以提高网络通信的效率和稳定性，例如在开发高性能的网络服务器时，新的 Socket API 能够更好地处理大量并发连接。</p>
<pre class="line-numbers language-none"><code class="language-none">import java.io.IOException;

import java.net.Socket;

public class SocketExample &#123;

       public static void main(String\[] args) &#123;

           try (Socket socket &#x3D; new Socket(&quot;www.example.com&quot;, 80)) &#123;

               &#x2F;&#x2F; 执行Socket操作

           &#125; catch (IOException e) &#123;

               e.printStackTrace();

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码展示了使用重新实现的 Socket API 创建一个简单的 Socket 连接。</p>
<h3 id="Switch-表达式（预览）"><a href="#Switch-表达式（预览）" class="headerlink" title="Switch 表达式（预览）"></a>Switch 表达式（预览）</h3><p>在 JDK 12 中引入的 switch 表达式在 JDK 13 中进行了第二次预览，此次修改引入了yield语句，用于返回值。这使得switch表达式不仅可以以陈述的方式，还能用表达式的方式使用，并且两种形式都可以用传统方式（case … : labels）或新的方式（case … -&gt; labels） ，为开发者提供了更灵活的条件判断方式。</p>
<pre class="line-numbers language-none"><code class="language-none">public class SwitchExpressionExample &#123;

       public static void main(String\[] args) &#123;

           int num &#x3D; 1;

           String result &#x3D; switch (num) &#123;

               case 1 -&gt; &quot;One&quot;;

               case 2 -&gt; &quot;Two&quot;;

               default -&gt; &quot;Other&quot;;

           &#125;;

           System.out.println(result);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，switch表达式根据num的值返回相应的字符串，使用yield语句简化了代码结构，提高了代码的可读性。</p>
<h3 id="文本块（预览）"><a href="#文本块（预览）" class="headerlink" title="文本块（预览）"></a>文本块（预览）</h3><p>文本块是 JDK 13 引入的另一个预览特性，它允许在 Java 中定义多行字符串，例如一段格式化后的 xml、json 等。使用文本块，用户不需要手动转义换行符等特殊字符，Java 能自动处理，使代码更加简洁易读。在处理 HTML、SQL 语句等包含多行文本的场景中，文本块特性可以大大提高代码的可读性和维护性。</p>
<pre class="line-numbers language-none"><code class="language-none">public class TextBlocksExample &#123;

       public static void main(String\[] args) &#123;

           &#x2F;&#x2F; 传统方式定义多行字符串

           String htmlBefore &#x3D; &quot;\&lt;html&gt;\n&quot; +

                               &quot;    \&lt;body&gt;\n&quot; +

                               &quot;        \&lt;p&gt;Hello, world\&lt;&#x2F;p&gt;\n&quot; +

                               &quot;    \&lt;&#x2F;body&gt;\n&quot; +

                               &quot;\&lt;&#x2F;html&gt;\n&quot;;

           &#x2F;&#x2F; 使用文本块定义多行字符串

           String htmlAfter &#x3D; &quot;&quot;&quot;

                   \&lt;html&gt;

                       \&lt;body&gt;

                           \&lt;p&gt;Hello, world\&lt;&#x2F;p&gt;

                       \&lt;&#x2F;body&gt;

                   \&lt;&#x2F;html&gt;

                   &quot;&quot;&quot;;

           System.out.println(htmlBefore);

           System.out.println(htmlAfter);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对比传统方式和使用文本块的方式，可以明显看出文本块的代码更加简洁直观，减少了因转义字符和字符串连接导致的错误。</p>
<p>JDK 13 的这些新特性虽然不是革命性的，但在性能优化、代码编写便利性等方面都有一定的提升，为 Java 开发者带来了更好的开发体验。</p>
<hr>
<h2 id="JDK-14"><a href="#JDK-14" class="headerlink" title="JDK 14"></a>JDK 14</h2><p><img src="https://picx.zhimg.com/80/v2-255d9739828e50f002a0d439d6371092_1440w.png?source=d16d100b"></p>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>JDK 14 在 2020 年 3 月发布，虽然不是长期支持（LTS）版本，但它带来的一系列新特性和改进同样令人瞩目，进一步推动了 Java 语言的发展和创新。</p>
<h3 id="模式匹配-for-instanceof（预览）"><a href="#模式匹配-for-instanceof（预览）" class="headerlink" title="模式匹配 for instanceof（预览）"></a>模式匹配 for instanceof（预览）</h3><p>在 JDK 14 之前，当我们使用instanceof判断对象类型后，若要使用该对象，还需要进行强制类型转换，代码略显繁琐。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; &quot;Hello, Java 14&quot;;

if (obj instanceof String) &#123;

       String str &#x3D; (String) obj;

       System.out.println(str.length());

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而在 JDK 14 中，引入了模式匹配for instanceof，可以在判断类型的同时进行赋值，使代码更加简洁和安全：</p>
<pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; &quot;Hello, Java 14&quot;;

if (obj instanceof String str) &#123;

       System.out.println(str.length());

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，obj instanceof String str不仅判断obj是否为String类型，还将obj赋值给str，后续可以直接使用str，无需显式的强制类型转换，减少了出错的可能性。</p>
<h3 id="Records（预览）"><a href="#Records（预览）" class="headerlink" title="Records（预览）"></a>Records（预览）</h3><p>Records 是 JDK 14 引入的一种新的类型声明，用于创建不可变的数据载体类，类似于传统的 POJO（Plain Old Java Object），但语法更加紧凑和简洁。它自动生成构造函数、访问器方法、equals、hashCode和toString方法，减少了样板代码的编写。例如，定义一个简单的Point类：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 传统方式定义类

class Point &#123;

       private final int x;

       private final int y;

       public Point(int x, int y) &#123;

           this.x &#x3D; x;

           this.y &#x3D; y;

       &#125;

       public int getX() &#123;

           return x;

       &#125;

       public int getY() &#123;

           return y;

       &#125;

       @Override

       public boolean equals(Object o) &#123;

           if (this &#x3D;&#x3D; o) return true;

           if (o &#x3D;&#x3D; null || getClass() !&#x3D; o.getClass()) return false;

           Point point &#x3D; (Point) o;

           return x &#x3D;&#x3D; point.x &amp;&amp; y &#x3D;&#x3D; point.y;

       &#125;

       @Override

       public int hashCode() &#123;

           return 31 \* x + y;

       &#125;

       @Override

       public String toString() &#123;

           return &quot;Point&#123;&quot; +

                   &quot;x&#x3D;&quot; + x +

                   &quot;, y&#x3D;&quot; + y +

                   &#39;&#125;&#39;;

       &#125;

&#125;

&#x2F;&#x2F; 使用Records定义类

public record PointRecord(int x, int y) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用PointRecord时，可以像使用传统类一样创建对象并访问其属性：</p>
<pre class="line-numbers language-none"><code class="language-none">PointRecord point &#x3D; new PointRecord(10, 20);

System.out.println(point.x()); &#x2F;&#x2F; 输出: 10

System.out.println(point.y()); &#x2F;&#x2F; 输出: 20

System.out.println(point);    &#x2F;&#x2F; 输出: PointRecord\[x&#x3D;10, y&#x3D;20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，使用 Records 定义的类，代码量大幅减少，并且自动生成的方法保证了类的正确性和一致性。</p>
<h3 id="Switch-表达式（标准）"><a href="#Switch-表达式（标准）" class="headerlink" title="Switch 表达式（标准）"></a>Switch 表达式（标准）</h3><p>在 JDK 12 和 JDK 13 中预览的 Switch 表达式在 JDK 14 中成为标准特性。它扩展了switch语句，使其不仅可以作为语句使用，还可以作为表达式使用，并且支持新的语法case … -&gt;，简化了代码编写。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">int day &#x3D; 3;

String dayType &#x3D; switch (day) &#123;

       case 1, 2, 3, 4, 5 -&gt; &quot;Weekday&quot;;

       case 6, 7 -&gt; &quot;Weekend&quot;;

       default -&gt; throw new IllegalArgumentException(&quot;Invalid day: &quot; + day);

&#125;;

System.out.println(dayType); &#x2F;&#x2F; 输出: Weekday<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，switch表达式根据day的值返回相应的字符串，使用yield关键字（在 JDK 13 中引入）来返回值，无需使用break语句，使代码结构更加清晰。</p>
<h3 id="文本块（第二预览）"><a href="#文本块（第二预览）" class="headerlink" title="文本块（第二预览）"></a>文本块（第二预览）</h3><p>文本块是 JDK 13 引入的预览特性，在 JDK 14 中进行了第二次预览。它允许定义多行字符串，无需使用大多数转义序列，并且可以自动处理换行和缩进，提高了代码的可读性。例如，定义一个包含 HTML 代码的字符串：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 传统方式定义多行字符串

String htmlBefore &#x3D; &quot;\&lt;html&gt;\n&quot; +

                       &quot;    \&lt;body&gt;\n&quot; +

                       &quot;        \&lt;p&gt;Hello, world\&lt;&#x2F;p&gt;\n&quot; +

                       &quot;    \&lt;&#x2F;body&gt;\n&quot; +

                       &quot;\&lt;&#x2F;html&gt;\n&quot;;

&#x2F;&#x2F; 使用文本块定义多行字符串

String htmlAfter &#x3D; &quot;&quot;&quot;

                   \&lt;html&gt;

                       \&lt;body&gt;

                           \&lt;p&gt;Hello, world\&lt;&#x2F;p&gt;

                       \&lt;&#x2F;body&gt;

                   \&lt;&#x2F;html&gt;

                   &quot;&quot;&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对比可以发现，使用文本块定义的字符串更加直观和简洁，无需手动添加转义字符和连接符，减少了出错的可能性。</p>
<h3 id="改进的-NullPointerException"><a href="#改进的-NullPointerException" class="headerlink" title="改进的 NullPointerException"></a>改进的 NullPointerException</h3><p>JDK 14 对NullPointerException进行了改进，提供更详细的异常信息，以便更容易定位问题。在之前的版本中，当发生NullPointerException时，通常只能看到异常发生的行号，难以确定具体是哪个变量为null。而在 JDK 14 中，会明确指出哪个变量为null。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; JDK 14之前的NullPointerException提示

String name &#x3D; null;

System.out.println(name.length()); &#x2F;&#x2F; 抛出NullPointerException，提示信息较模糊
&#x2F;&#x2F; JDK 14中的NullPointerException提示

String name &#x3D; null;

System.out.println(name.length());  

&#x2F;&#x2F; 抛出NullPointerException: Cannot invoke &quot;String.length()&quot; because &quot;name&quot; is null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，JDK 14 的异常提示更加详细，有助于快速定位和解决空指针异常问题。</p>
<h3 id="针对-G1-的-NUMA-内存分配优化"><a href="#针对-G1-的-NUMA-内存分配优化" class="headerlink" title="针对 G1 的 NUMA 内存分配优化"></a>针对 G1 的 NUMA 内存分配优化</h3><p>JDK 14 对 G1 垃圾收集器进行了优化，使其在非一致性内存访问（NUMA）体系结构的机器上性能得到提升。通过实现 NUMA-aware 内存分配，G1 垃圾收集器尝试在垃圾回收过程中，在年轻一代的同一 NUMA 节点上分配并保留对象，类似于并行 GC 的 NUMA 意识。这有助于减少跨节点内存访问的开销，提高应用程序在大型机器上的性能。使用时，通过-XX：+UseNUMA命令行选项自动启用这些新的 NUMA 感知内存分配试探法。</p>
<h3 id="JFR-事件流"><a href="#JFR-事件流" class="headerlink" title="JFR 事件流"></a>JFR 事件流</h3><p>JDK 14 引入了 JDK Flight Recorder（JFR）事件流，这是 JDK 11 飞行记录器的升级功能。在 JDK 11 中，JFR 只能将运行的数据导出文件，然后通过 JMC 可视化，这个过程较为繁琐且不能应用于实时监控。而在 JDK 14 中，通过 JFR 事件流可以实时获取到 JVM 的运行情况，为开发者提供了更便捷的监控手段，有助于及时发现和解决性能问题。例如，可以使用以下代码获取 JFR 事件流：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.jfr.Configuration;

import jdk.jfr.consumer.RecordingStream;

public class JfrEventStreamExample &#123;

       public static void main(String\[] args) &#123;

           Configuration config &#x3D; Configuration.getConfiguration(&quot;default&quot;);

           try (RecordingStream stream &#x3D; new RecordingStream(config)) &#123;

               stream.onEvent(&quot;jdk.GCPhasePause&quot;, event -&gt; &#123;

                   System.out.println(&quot;GC Pause: &quot; + event.getStartTime());

               &#125;);

               stream.start();

               &#x2F;&#x2F; 模拟一些操作，触发GC

               for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;

                   new Object();

               &#125;

               &#x2F;&#x2F; 保持主线程运行，以便观察事件流

               while (true) &#123;

                   try &#123;

                       Thread.sleep(1000);

                   &#125; catch (InterruptedException e) &#123;

                       Thread.currentThread().interrupt();

                       break;

                   &#125;

               &#125;

           &#125; catch (Exception e) &#123;

               e.printStackTrace();

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过RecordingStream监听jdk.GCPhasePause事件，当发生 GC 暂停时，打印出暂停的开始时间。</p>
<h3 id="移除-CMS-垃圾收集器"><a href="#移除-CMS-垃圾收集器" class="headerlink" title="移除 CMS 垃圾收集器"></a>移除 CMS 垃圾收集器</h3><p>在 JDK 14 中，CMS（Concurrent Mark Sweep）垃圾收集器被移除。CMS 是一种老年代垃圾收集器，在高并发应用中曾被广泛使用，但随着 G1 等更先进的垃圾收集器的发展，CMS 的局限性逐渐凸显。移除 CMS 旨在简化 JVM 的垃圾收集器实现，推动开发者使用更高效、更现代化的垃圾收集器，如 G1 和 ZGC。如果在 JDK 14 中尝试使用-XX:UseConcMarkSweepGC或其别名（如-Xconcgc，-Xnoconcgc）以及所有 CMS 特定选项，将会抛出错误，提示该垃圾收集器已被移除。</p>
<h3 id="ZGC-支持-macOS-和-Windows-平台"><a href="#ZGC-支持-macOS-和-Windows-平台" class="headerlink" title="ZGC 支持 macOS 和 Windows 平台"></a>ZGC 支持 macOS 和 Windows 平台</h3><p>JDK 14 将 ZGC 垃圾回收器的支持扩展到了 macOS 和 Windows 平台。ZGC 是一种可扩展的低延迟垃圾收集器，目标是实现亚毫秒级的最大停顿时间，并且停顿时间不会随着堆、存活对象集或根对象集的大小而增加。在 macOS 和 Windows 平台上使用 ZGC，可以为这些平台上的 Java 应用带来更高效的内存管理和更低的延迟。使用时，需要添加-XX:+UnlockExperimentalVMOptions -XX:+UseZGC参数来启用 ZGC。例如，在 Windows 平台上启动 Java 应用时，可以使用以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx4g MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上述命令启用了 ZGC，并设置最大堆内存为 4GB。</p>
<h3 id="弃用-ParallelScavenge-SerialOld-GC-组合"><a href="#弃用-ParallelScavenge-SerialOld-GC-组合" class="headerlink" title="弃用 ParallelScavenge + SerialOld GC 组合"></a>弃用 ParallelScavenge + SerialOld GC 组合</h3><p>JDK 14 弃用了ParallelScavenge + SerialOld垃圾回收算法组合。ParallelScavenge是新生代垃圾收集器，注重吞吐量，SerialOld是老年代垃圾收集器。随着 Java 垃圾收集技术的发展，这种组合在性能和功能上逐渐无法满足需求。弃用该组合有助于推动开发者采用更先进的垃圾收集器组合，如ParallelScavenge + ParallelOld或 G1 等。当使用UseParallelOldGC命令行选项启用此垃圾回收算法组合时，会引起弃用警告，建议使用-XX:+UseParallelGC来启用ParallelScavenge + ParallelOld垃圾收集器。</p>
<h3 id="非易失性映射的字节缓冲区"><a href="#非易失性映射的字节缓冲区" class="headerlink" title="非易失性映射的字节缓冲区"></a>非易失性映射的字节缓冲区</h3><p>JDK 14 引入了新的 JDK 特定文件映射模式，允许FileChannel API 用于创建引用非易失性内存（NVM）的MappedByteBuffer实例。非易失性内存是一种即使在断电后数据也能保留的内存类型，这一特性为处理需要持久化存储的数据提供了更高效的方式。例如，在处理大型数据文件时，可以使用非易失性映射的字节缓冲区来提高数据访问和处理的效率：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.io.FileChannel;

import java.io.IOException;

import java.nio.ByteBuffer;

import java.nio.MappedByteBuffer;

import java.nio.channels.FileChannel.MapMode;

import java.nio.file.Paths;

import java.nio.file.StandardOpenOption;

public class NonVolatileMappedByteBufferExample &#123;

       public static void main(String\[] args) &#123;

           try (FileChannel channel &#x3D; FileChannel.open(Paths.get(&quot;data.txt&quot;), StandardOpenOption.READ)) &#123;

               &#x2F;&#x2F; 创建非易失性映射的字节缓冲区

               MappedByteBuffer buffer &#x3D; channel.map(MapMode.READ\_ONLY, 0, channel.size());

               &#x2F;&#x2F; 处理缓冲区中的数据

               while (buffer.hasRemaining()) &#123;

                   byte b &#x3D; buffer.get();

                   &#x2F;&#x2F; 进行数据处理操作

               &#125;

           &#125; catch (IOException e) &#123;

               e.printStackTrace();

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过FileChannel的map方法创建了一个非易失性映射的字节缓冲区，用于读取文件中的数据。</p>
<h3 id="外部内存访问-API（孵化阶段）"><a href="#外部内存访问-API（孵化阶段）" class="headerlink" title="外部内存访问 API（孵化阶段）"></a>外部内存访问 API（孵化阶段）</h3><p>JDK 14 在孵化器模块中添加了新的外部内存访问 API，允许 Java 程序安全有效地访问 Java 堆之外的外部内存。这一 API 为开发需要处理大量数据或与本地代码交互的应用提供了更灵活的内存管理方式，例如在高性能计算、大数据处理等领域。虽然该 API 还处于孵化阶段，但它展示了 Java 在内存管理方面的进一步探索和发展。使用该 API 时，需要引入相关的模块和依赖，并遵循其特定的使用规范。例如，以下是一个简单的示例，展示了如何使用外部内存访问 API 分配和访问外部内存：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.foreign.\*;

import java.lang.foreign.MemorySegment;

import java.lang.foreign.MemorySession;

import java.lang.foreign.ValueLayout;

public class ExternalMemoryAccessExample &#123;

       public static void main(String\[] args) &#123;

           try (MemorySession session &#x3D; MemorySession.openConfined()) &#123;

               &#x2F;&#x2F; 分配1024字节的外部内存

               MemorySegment segment &#x3D; session.allocateNative(1024);

               &#x2F;&#x2F; 获取指向该内存段的地址

               MemoryAddress address &#x3D; segment.address();

               &#x2F;&#x2F; 写入数据到内存段

               ValueLayout.JAVA\_INT layout &#x3D; ValueLayout.JAVA\_INT;

               segment.set(layout, 0, 42);

               &#x2F;&#x2F; 从内存段读取数据

               int value &#x3D; segment.get(layout, 0);

               System.out.println(&quot;Read value: &quot; + value); &#x2F;&#x2F; 输出: Read value: 42

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过MemorySession分配了 1024 字节的外部内存，并使用MemorySegment对该内存进行操作，实现了数据的写入和读取。</p>
<p>JDK 14 的这些新特性和改进，无论是在语言特性、垃圾回收，还是在内存管理和监控方面，都为 Java 开发者带来了更多的选择和更好的开发体验，也为 Java 语言的未来发展奠定了坚实的基础。</p>
<hr>
<h2 id="JDK-15"><a href="#JDK-15" class="headerlink" title="JDK 15"></a>JDK 15</h2><p>JDK 15 于 2020 年 9 月发布，带来了多项引人注目的新特性和改进，这些变化进一步丰富了 Java 语言的功能，提升了开发效率和应用性能。</p>
<h3 id="密封类（预览）"><a href="#密封类（预览）" class="headerlink" title="密封类（预览）"></a>密封类（预览）</h3><p>密封类是 JDK 15 引入的一个重要特性，用于限制超类的使用。通过sealed关键字修饰类或接口，开发者可以明确指定哪些类或接口可以继承或实现它，从而增强代码的安全性和可维护性。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">public abstract sealed class Shape permits Circle, Rectangle &#123;

       &#x2F;&#x2F; 定义形状的抽象类

&#125;

final class Circle extends Shape &#123;

       &#x2F;&#x2F; 圆形类

&#125;

final class Rectangle extends Shape &#123;

       &#x2F;&#x2F; 矩形类

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，Shape是一个密封类，只有Circle和Rectangle被允许继承它，其他类无法随意扩展Shape，这有助于在复杂的类层次结构中保持代码的清晰性和可控性。</p>
<h3 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h3><p>隐藏类是为框架设计的，它不能直接被其他类的字节码使用，只能在运行时生成并通过反射间接使用。隐藏类的主要特点包括不可发现性、访问控制和独立的生命周期。许多基于 JVM 的语言利用隐藏类来动态生成类，提高灵活性和效率。例如，JDK 8 中的 lambda 表达式在运行时动态生成相应的类对象，这些类就可以被定义为隐藏类。</p>
<pre class="line-numbers language-none"><code class="language-none">import java.lang.invoke.LambdaMetaFactory;

import java.lang.invoke.MethodHandle;

import java.lang.invoke.MethodType;

public class HiddenClassExample &#123;

       public static void main(String\[] args) throws Exception &#123;

           MethodType methodType &#x3D; MethodType.methodType(void.class);

           MethodHandle methodHandle &#x3D; LambdaMetaFactory.metafactory(

                   null, &quot;run&quot;, methodType, methodType)

                   .getTarget();

           methodHandle.invoke();

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，通过LambdaMetaFactory生成了一个隐藏类，用于实现 lambda 表达式的功能。</p>
<h3 id="instanceof-模式匹配（第二次预览）"><a href="#instanceof-模式匹配（第二次预览）" class="headerlink" title="instanceof 模式匹配（第二次预览）"></a>instanceof 模式匹配（第二次预览）</h3><p>在 JDK 14 中首次预览的instanceof模式匹配在 JDK 15 中进行了第二次预览。它允许在instanceof检查的同时进行类型转换，使代码更加简洁和安全。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; &quot;Hello, Java 15&quot;;

if (obj instanceof String s) &#123;

       System.out.println(s.length()); &#x2F;&#x2F; 直接使用s，无需显式转换

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>相比于传统的instanceof用法，模式匹配减少了冗余的类型转换代码，提高了代码的可读性。</p>
<h3 id="ZGC-转正"><a href="#ZGC-转正" class="headerlink" title="ZGC 转正"></a>ZGC 转正</h3><p>ZGC（Z Garbage Collector）是一个可扩展的低延迟垃圾收集器，最早在 JDK 11 中引入作为实验性特性。经过多个版本的改进和优化，在 JDK 15 中，ZGC 正式转正。ZGC 的目标是实现亚毫秒级的最大停顿时间，并且停顿时间不会随着堆、存活对象集或根对象集的大小而增加。它采用了染色指针、读屏障和基于 Region 的内存布局等技术，能够高效地处理大内存堆（从 8MB 到 16TB）的场景。在高并发、大内存的应用场景中，如电商平台的后端服务，ZGC 可以显著提升系统的性能和稳定性，确保在大量数据处理和高并发请求下，应用仍能保持低延迟响应 。</p>
<pre class="line-numbers language-none"><code class="language-none">\# 使用ZGC启动Java应用

java -XX:+UseZGC -Xmx4g MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上述命令启用了 ZGC，并设置最大堆内存为 4GB。</p>
<h3 id="文本块转正"><a href="#文本块转正" class="headerlink" title="文本块转正"></a>文本块转正</h3><p>文本块在 JDK 13 中作为预览特性引入，经过 JDK 14 的再次预览，在 JDK 15 中正式成为 Java 语言的一部分。文本块允许定义多行字符串，无需使用大多数转义序列，并且可以自动处理换行和缩进，提高了代码的可读性。在处理 HTML、SQL 语句等包含多行文本的场景中，文本块特性非常实用。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 传统方式定义多行字符串

String htmlBefore &#x3D; &quot;\&lt;html&gt;\n&quot; +

                       &quot;    \&lt;body&gt;\n&quot; +

                       &quot;        \&lt;p&gt;Hello, world\&lt;&#x2F;p&gt;\n&quot; +

                       &quot;    \&lt;&#x2F;body&gt;\n&quot; +

                       &quot;\&lt;&#x2F;html&gt;\n&quot;;

&#x2F;&#x2F; 使用文本块定义多行字符串

String htmlAfter &#x3D; &quot;&quot;&quot;

                   \&lt;html&gt;

                       \&lt;body&gt;

                           \&lt;p&gt;Hello, world\&lt;&#x2F;p&gt;

                       \&lt;&#x2F;body&gt;

                   \&lt;&#x2F;html&gt;

                   &quot;&quot;&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以明显看出，使用文本块定义的字符串更加简洁直观，减少了因转义字符和字符串连接导致的错误。</p>
<h3 id="其他特性-1"><a href="#其他特性-1" class="headerlink" title="其他特性"></a>其他特性</h3><p>EdDSA 数字签名算法：引入 Edwards 曲线数字签名算法（EdDSA），与其他签名方案相比，EdDSA 具有更高的安全性和性能，并且已有很多其他加密库（如 OpenSSL 和 BoringSSL）支持此签名方案。EdDSA 是 TLS 1.3 的可选组件，且是 TLS 1.3 中仅有的三种签名方案之一 ，为 Java 应用提供了更强大的加密签名能力。</p>
<p>移除 Nashorn JavaScript 引擎：Nashorn JavaScript 引擎在 JDK 11 中已被标记为弃用，在 JDK 15 中被正式移除。随着 ECMAScript 脚本语言的结构、API 的改编速度越来越快，维护 Nashorn 的难度增大，这一移除也是 Java 发展过程中的一次调整。</p>
<p>重新实现 DatagramSocket API：对java.net``.DatagramSocket和java.net``.MulticastSocket的底层实现进行了重新设计，采用了更简单、现代化的实现方式，更易于维护和调试，并且新的底层实现将很容易使用虚拟线程，为网络编程提供了更好的支持。</p>
<p>禁用偏向锁：在 JDK 15 中，默认情况下禁用偏向锁，并弃用所有相关的命令行选项。偏向锁是一种优化机制，旨在减少无竞争情况下的锁开销，但在某些场景下，维护偏向锁的成本较高，此次禁用和弃用是为了简化 JVM 的锁机制 。</p>
<p>JDK 15 的这些新特性和改进，无论是在语言特性的增强、垃圾回收器的优化，还是在安全性和性能提升方面，都为 Java 开发者带来了更多的便利和选择，推动了 Java 技术的不断发展和进步。</p>
<hr>
<h2 id="JDK-16"><a href="#JDK-16" class="headerlink" title="JDK 16"></a>JDK 16</h2><p>JDK 16 于 2021 年 3 月发布，引入了 17 个 JEP，在性能、稳定性和功能上都有显著提升。这些改进旨在让 Java 更高效、更安全，同时增强开发体验。</p>
<h3 id="增强的-G1-垃圾回收器"><a href="#增强的-G1-垃圾回收器" class="headerlink" title="增强的 G1 垃圾回收器"></a>增强的 G1 垃圾回收器</h3><p>G1 垃圾回收器在 JDK 16 中得到了进一步优化，通过改进并发标记和混合回收阶段，显著降低了 GC 暂停时间。在大型应用中，大量对象的创建和销毁会频繁触发垃圾回收，而 G1 的优化能确保应用在高负载下仍保持高效运行，减少因 GC 暂停对用户体验的影响。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 启用G1垃圾回收器，在启动时添加参数：-XX:+UseG1GC

public class G1GCExample &#123;

       public static void main(String\[] args) &#123;

           List\&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();

           while (true) &#123;

               list.add(new Object());

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在实际应用中，如电商平台的订单处理系统，大量订单数据的创建和过期处理会产生频繁的内存分配和回收，G1 垃圾回收器的优化能有效提升系统的响应速度和吞吐量，确保在高并发场景下，系统仍能快速处理用户请求。</p>
<h3 id="外部内存访问-API（第三次孵化）"><a href="#外部内存访问-API（第三次孵化）" class="headerlink" title="外部内存访问 API（第三次孵化）"></a>外部内存访问 API（第三次孵化）</h3><p>此 API 允许 Java 程序安全有效地访问 Java 堆之外的外部内存，为开发人员提供了更灵活的内存管理方式。在需要处理大量数据或与本地代码交互的场景中，如高性能计算、大数据处理等领域，开发人员可以利用该 API 直接操作外部内存，避免了频繁的数据拷贝，提高了数据处理的效率。</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.foreign.\*;

import java.lang.foreign.MemorySegment;

import java.lang.foreign.MemorySession;

import java.lang.foreign.ValueLayout;

public class ForeignMemoryAccessExample &#123;

       public static void main(String\[] args) &#123;

           try (MemorySession session &#x3D; MemorySession.openConfined()) &#123;

               &#x2F;&#x2F; 分配1024字节的外部内存

               MemorySegment segment &#x3D; session.allocateNative(1024);

               &#x2F;&#x2F; 获取指向该内存段的地址

               MemoryAddress address &#x3D; segment.address();

               &#x2F;&#x2F; 写入数据到内存段

               ValueLayout.JAVA\_INT layout &#x3D; ValueLayout.JAVA\_INT;

               segment.set(layout, 0, 42);

               &#x2F;&#x2F; 从内存段读取数据

               int value &#x3D; segment.get(layout, 0);

               System.out.println(&quot;Read value: &quot; + value); &#x2F;&#x2F; 输出: Read value: 42

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如，在大数据分析中，需要处理海量的数据集，使用外部内存访问 API 可以直接访问存储在外部内存中的数据，减少内存拷贝的开销，提高数据分析的速度。</p>
<h3 id="instanceof-模式匹配（转正）"><a href="#instanceof-模式匹配（转正）" class="headerlink" title="instanceof 模式匹配（转正）"></a>instanceof 模式匹配（转正）</h3><p>在 JDK 14 和 JDK 15 中预览的 instanceof 模式匹配在 JDK 16 中正式转正。它允许在instanceof检查的同时进行类型转换，使代码更加简洁和安全。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; &quot;Hello, Java 16&quot;;

if (obj instanceof String s) &#123;

       System.out.println(s.length()); &#x2F;&#x2F; 直接使用s，无需显式转换

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>相比于传统的instanceof用法，模式匹配减少了冗余的类型转换代码，降低了出错的可能性，提高了代码的可读性和可维护性。在实际开发中，如在处理各种类型的用户输入数据时，使用 instanceof 模式匹配可以更简洁地判断数据类型并进行相应处理。</p>
<h3 id="记录类（正式特性）"><a href="#记录类（正式特性）" class="headerlink" title="记录类（正式特性）"></a>记录类（正式特性）</h3><p>记录类在 JDK 14 中作为预览特性引入，在 JDK 16 中成为正式特性。记录类是一种特殊的类，用于创建不可变的数据载体，它自动生成构造函数、访问器方法、equals、hashCode和toString方法，减少了样板代码的编写。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">public record Point(int x, int y) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用Point记录类时，可以像使用传统类一样创建对象并访问其属性：</p>
<pre class="line-numbers language-none"><code class="language-none">Point point &#x3D; new Point(10, 20);

System.out.println(point.x()); &#x2F;&#x2F; 输出: 10

System.out.println(point.y()); &#x2F;&#x2F; 输出: 20

System.out.println(point);    &#x2F;&#x2F; 输出: Point\[x&#x3D;10, y&#x3D;20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在数据传输对象（DTO）的场景中，记录类可以大大简化代码的编写，提高开发效率，同时保证数据的不可变性和正确性。</p>
<h3 id="密封类（第二次预览）"><a href="#密封类（第二次预览）" class="headerlink" title="密封类（第二次预览）"></a>密封类（第二次预览）</h3><p>密封类在 JDK 15 中首次预览，JDK 16 中进行了第二次预览。密封类限制了其他类或接口可以扩展或实现它们，有助于提高代码的安全性和可维护性。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">public sealed class Shape permits Circle, Rectangle &#123;

       &#x2F;&#x2F; 类定义

&#125;

final class Circle extends Shape &#123;

       &#x2F;&#x2F; 圆形的实现

&#125;

final class Rectangle extends Shape &#123;

       &#x2F;&#x2F; 矩形的实现

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，Shape是一个密封类，只有Circle和Rectangle被允许扩展它，其他类无法随意继承Shape，从而避免了意外的子类化，使代码结构更加清晰和可控。在图形绘制库的开发中，使用密封类可以确保形状类的继承体系更加可控，便于维护和扩展。</p>
<hr>
<h2 id="JDK-17"><a href="#JDK-17" class="headerlink" title="JDK 17"></a>JDK 17</h2><p>JDK 17 于 2021 年 9 月发布，作为长期支持（LTS）版本，它在性能、功能和安全性等方面都有显著提升，为 Java 开发者提供了更强大的工具和更稳定的开发环境，成为企业级应用开发的重要选择 。</p>
<h3 id="密封类（转正）"><a href="#密封类（转正）" class="headerlink" title="密封类（转正）"></a>密封类（转正）</h3><p>密封类在 JDK 15 和 JDK 16 中进行了预览，在 JDK 17 中正式转正。它通过限制哪些类可以继承或实现特定的类或接口，增强了代码的安全性和可维护性。例如，在图形绘制库中，可以定义一个密封的Shape类，只允许Circle和Rectangle等特定的类继承它：</p>
<pre class="line-numbers language-none"><code class="language-none">public sealed class Shape permits Circle, Rectangle &#123;

       &#x2F;&#x2F; 定义一些通用的属性和方法

&#125;

final class Circle extends Shape &#123;

       &#x2F;&#x2F; 圆形的具体实现

&#125;

final class Rectangle extends Shape &#123;

       &#x2F;&#x2F; 矩形的具体实现

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，Shape是密封类，只有Circle和Rectangle被允许继承它，其他类无法随意扩展Shape，这有助于在复杂的类层次结构中保持代码的清晰性和可控性。</p>
<h3 id="Switch-表达式的模式匹配（预览）"><a href="#Switch-表达式的模式匹配（预览）" class="headerlink" title="Switch 表达式的模式匹配（预览）"></a>Switch 表达式的模式匹配（预览）</h3><p>JDK 17 引入了switch表达式的模式匹配，使得switch语句可以更方便地处理不同类型的对象，无需进行显式的类型转换。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; &quot;Hello, Java 17&quot;;

switch (obj) &#123;

       case String s -&gt; System.out.println(s.length());

       case Integer i -&gt; System.out.println(i \* 2);

       default -&gt; System.out.println(&quot;Unknown type&quot;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，switch表达式根据obj的类型进行不同的处理，当obj是String类型时，输出其长度；当obj是Integer类型时，输出其乘以 2 的结果。这种模式匹配的方式使代码更加简洁和直观，减少了繁琐的类型判断和转换代码。</p>
<h3 id="记录类（正式特性）-1"><a href="#记录类（正式特性）-1" class="headerlink" title="记录类（正式特性）"></a>记录类（正式特性）</h3><p>记录类在 JDK 14 中作为预览特性引入，在 JDK 17 中成为正式特性。记录类是一种特殊的类，用于创建不可变的数据载体，它自动生成构造函数、访问器方法、equals、hashCode和toString方法，减少了样板代码的编写。例如，定义一个表示坐标点的记录类：</p>
<pre class="line-numbers language-none"><code class="language-none">public record Point(int x, int y) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用Point记录类时，可以像使用传统类一样创建对象并访问其属性：</p>
<pre class="line-numbers language-none"><code class="language-none">Point point &#x3D; new Point(10, 20);

System.out.println(point.x()); &#x2F;&#x2F; 输出: 10

System.out.println(point.y()); &#x2F;&#x2F; 输出: 20

System.out.println(point);    &#x2F;&#x2F; 输出: Point\[x&#x3D;10, y&#x3D;20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在数据传输对象（DTO）的场景中，记录类可以大大简化代码的编写，提高开发效率，同时保证数据的不可变性和正确性。</p>
<h3 id="外部函数和内存-API（孵化）"><a href="#外部函数和内存-API（孵化）" class="headerlink" title="外部函数和内存 API（孵化）"></a>外部函数和内存 API（孵化）</h3><p>JDK 17 引入了外部函数和内存 API（Foreign Function &amp; Memory API）的孵化版本，允许 Java 程序与外部代码和数据进行交互，例如调用 C 语言的函数或访问外部内存。这对于需要与现有的 C 或 C++ 代码库进行集成，或者需要直接访问底层硬件资源的应用程序非常有用。例如，使用外部函数和内存 API 调用 C 语言的puts函数：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.lang.invoke.MethodHandles;

import java.lang.invoke.VarHandle;

import java.nio.Buffer;

import java.nio.ByteBuffer;

import java.nio.charset.StandardCharsets;

import java.util.Arrays;

import jdk.incubator.foreign.\*;

public class ForeignFunctionAndMemoryAPIDemo &#123;

       public static void main(String\[] args) &#123;

           try (var linker &#x3D; Linker.nativeLinker()) &#123;

               &#x2F;&#x2F; 加载C函数库

               var lib &#x3D; linker.load(&quot;libc.so.6&quot;);

               &#x2F;&#x2F; 查找C函数

               var putsFunc &#x3D; lib.lookup(&quot;puts&quot;).get();

               &#x2F;&#x2F; 调用C函数

               putsFunc.invoke(&quot;Hello from JDK 17 Foreign Function &amp; Memory API!&quot;);

           &#125; catch (Throwable e) &#123;

               e.printStackTrace();

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，首先使用Linker.nativeLinker()获取一个链接器，然后加载 C 函数库，查找puts函数，并调用它输出一条消息。这一 API 为 Java 开发者提供了一种更方便的方式进行跨语言开发，使得 Java 程序能够与其他语言编写的代码进行无缝集成，充分利用各种语言的优势。</p>
<h3 id="向量-API（第二次孵化）"><a href="#向量-API（第二次孵化）" class="headerlink" title="向量 API（第二次孵化）"></a>向量 API（第二次孵化）</h3><p>向量 API 旨在利用现代处理器的 SIMD（Single Instruction, Multiple Data）指令集，实现高效的向量化计算，提高数值计算的性能。在 JDK 17 中，向量 API 进行了第二次孵化，进一步完善和优化。向量 API 适用于科学计算、图像处理、机器学习等领域，其中涉及大量的数值计算和数据处理。例如，使用向量 API 进行浮点数加法运算：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.vector.FloatVector;

public class VectorAPIExample &#123;

       public static void main(String\[] args) &#123;

           &#x2F;&#x2F; 创建两个向量

           FloatVector va &#x3D; FloatVector.fromArray(FloatVector.SPECIES\_256, new float\[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;);

           FloatVector vb &#x3D; FloatVector.fromArray(FloatVector.SPECIES\_256, new float\[]&#123;8, 7, 6, 5, 4, 3, 2, 1&#125;);

           &#x2F;&#x2F; 向量加法

           FloatVector vc &#x3D; va.add(vb);

           &#x2F;&#x2F; 将结果转换回数组

           float\[] resultArray &#x3D; new float\[8];

           vc.intoArray(resultArray, 0);

           for (float value : resultArray) &#123;

               System.out.println(value);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，首先创建了两个向量va和vb，然后使用向量的加法操作得到vc，最后将结果转换回数组并输出。与传统的逐个元素进行计算的方式相比，向量 API 可以显著提高性能，充分利用硬件的并行处理能力，减少计算时间。</p>
<h3 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h3><p>JDK 17 在性能方面进行了多方面的优化，包括垃圾回收、编译器和内存模型等方面。这些优化旨在提高应用程序的响应速度和吞吐量。特别是 ZGC（Z Garbage Collector）和 G1（Garbage-First）收集器的改进，为应用提供了更低的延迟和更高的吞吐量。在高并发、大内存的应用场景中，如电商平台的后端服务，ZGC 和 G1 收集器的优化能有效提升系统的性能和稳定性，确保在大量数据处理和高并发请求下，应用仍能保持低延迟响应。</p>
<h3 id="安全性增强"><a href="#安全性增强" class="headerlink" title="安全性增强"></a>安全性增强</h3><p>JDK 17 在安全性方面进行了更多的改进。例如，对密码套件进行了升级，支持 TLSv1.3 协议，并默认启用了安全协议。这些改进有助于增强应用程序的安全性，防止恶意攻击。在网络通信中，TLSv1.3 协议提供了更高的安全性和性能，默认启用安全协议可以确保应用在传输数据时的安全性，保护用户数据不被窃取和篡改。</p>
<hr>
<h2 id="JDK-18"><a href="#JDK-18" class="headerlink" title="JDK 18"></a>JDK 18</h2><p>JDK 18 于 2022 年 3 月发布，虽然是一个短期版本，但引入的新特性依然为 Java 开发者带来了诸多便利和新的编程思路。</p>
<h3 id="UTF-8-成为默认字符集"><a href="#UTF-8-成为默认字符集" class="headerlink" title="UTF-8 成为默认字符集"></a>UTF-8 成为默认字符集</h3><p>在 JDK 18 之前，Java 的默认字符集依赖于操作系统和区域设置，这在跨平台开发中容易引发字符编码不一致的问题。而 JDK 18 将 UTF-8 指定为标准 Java API 的默认字符集，使得依赖默认字符集的 API 在不同的实现、操作系统、区域设置和配置中保持一致，有效减少了字符编码相关的错误。例如，在读取文件时，之前可能需要显式指定字符集，现在默认就使用 UTF-8：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; JDK 18之前

BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(&quot;file.txt&quot;), &quot;UTF-8&quot;));

&#x2F;&#x2F; JDK 18之后，默认使用UTF-8

BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(&quot;file.txt&quot;)));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样一来，开发者无需再为不同环境下的字符集差异而烦恼，降低了开发和维护成本，提高了代码的可移植性。</p>
<h3 id="简单的-Web-服务器（预览）"><a href="#简单的-Web-服务器（预览）" class="headerlink" title="简单的 Web 服务器（预览）"></a>简单的 Web 服务器（预览）</h3><p>JDK 18 引入了一个简单的 Web 服务器，作为一个预览特性，为开发者提供了一种轻量级、便捷的方式来创建和运行 Web 应用程序。它可以快速搭建一个仅提供静态文件的最小网络服务器，适用于原型开发、临时编码和测试目的，尤其是在教学环境中。例如，使用以下命令即可启动一个简单的 Web 服务器，默认监听本地的 8000 端口，提供当前目录及其子目录下的静态文件服务：</p>
<pre class="line-numbers language-none"><code class="language-none">java -m jwebserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以通过参数指定监听地址和端口，如：</p>
<pre class="line-numbers language-none"><code class="language-none">java -m jwebserver -b 0.0.0.0 -p 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这使得开发者在进行简单的 Web 开发或测试时，无需依赖外部的 Web 服务器软件，直接使用 JDK 自带的工具即可快速验证想法和实现功能。</p>
<h3 id="Java-API-文档支持代码片段"><a href="#Java-API-文档支持代码片段" class="headerlink" title="Java API 文档支持代码片段"></a>Java API 文档支持代码片段</h3><p>JDK 18 为 JavaDoc 的 Standard Doclet 引入了@snippet标记，简化了在 API 文档中嵌入示例源代码的难度。使用@snippet标记，可以更方便地展示代码示例，并且支持代码的自动语法高亮和格式化，提高了文档的可读性和实用性。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;\*\*

    \* 计算两个整数的和

    \*

    \* @param a 第一个整数

    \* @param b 第二个整数

    \* @return 两个整数的和

    \* @snippet :

    \* int result &#x3D; add(3, 5);

    \* System.out.println(result); &#x2F;&#x2F; 输出: 8

    \*&#x2F;

public int add(int a, int b) &#123;

       return a + b;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在生成的 JavaDoc 文档中，代码片段会以清晰的格式展示，方便其他开发者理解和使用该方法。</p>
<h3 id="重新实现核心反射（Method-Handles）"><a href="#重新实现核心反射（Method-Handles）" class="headerlink" title="重新实现核心反射（Method Handles）"></a>重新实现核心反射（Method Handles）</h3><p>JDK 18 在java.lang.invoke的方法句柄之上，重构了java.lang.reflect的方法、构造函数和字段，使用方法句柄处理反射的底层机制。这一改进将减少java.lang.reflect和java.lang.invoke两者的 API 维护和开发成本，并且可能带来性能上的提升。在使用反射获取类的方法并调用时，新的实现方式更加简洁高效：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.lang.invoke.MethodHandles;

import java.lang.reflect.Method;

public class ReflectionExample &#123;

       public static void main(String\[] args) throws Throwable &#123;

           Method method &#x3D; String.class.getMethod(&quot;substring&quot;, int.class, int.class);

           MethodHandles.Lookup lookup &#x3D; MethodHandles.lookup();

           var handle &#x3D; lookup.unreflect(method);

           String result &#x3D; (String) handle.invoke(&quot;Hello, Java 18&quot;, 7, 12);

           System.out.println(result); &#x2F;&#x2F; 输出: Java 18

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过这种方式，开发者可以更灵活地使用反射机制，并且在性能敏感的场景中获得更好的表现。</p>
<h3 id="Vector-API（第三次孵化）"><a href="#Vector-API（第三次孵化）" class="headerlink" title="Vector API（第三次孵化）"></a>Vector API（第三次孵化）</h3><p>JDK 18 中 Vector API 进入第三次孵化阶段，该 API 用于表示在运行时可靠地编译到支持的 CPU 架构上的最佳矢量硬件指令的矢量计算，旨在提高数值计算的性能，在机器学习、人工智能和密码学等领域有着广泛的应用。例如，使用 Vector API 进行浮点数向量加法：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.vector.FloatVector;

import jdk.incubator.vector.VectorSpecies;

public class VectorAdditionExample &#123;

       public static void main(String\[] args) &#123;

           VectorSpecies\&lt;Float&gt; species &#x3D; FloatVector.SPECIES\_256;

           float\[] a &#x3D; &#123;1.0f, 2.0f, 3.0f, 4.0f&#125;;

           float\[] b &#x3D; &#123;5.0f, 6.0f, 7.0f, 8.0f&#125;;

           FloatVector va &#x3D; FloatVector.fromArray(species, a, 0);

           FloatVector vb &#x3D; FloatVector.fromArray(species, b, 0);

           FloatVector vc &#x3D; va.add(vb);

           float\[] result &#x3D; new float\[4];

           vc.intoArray(result, 0);

           for (float value : result) &#123;

               System.out.println(value);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码展示了如何使用 Vector API 创建浮点数向量，并进行加法操作，与传统的逐个元素计算方式相比，使用 Vector API 可以充分利用硬件的并行处理能力，显著提高计算效率。</p>
<h3 id="互联网地址解析-SPI"><a href="#互联网地址解析-SPI" class="headerlink" title="互联网地址解析 SPI"></a>互联网地址解析 SPI</h3><p>JDK 18 定义了一个全新的 SPI（service-provider interface），用于主要名称和地址的解析，以便java.net``.InetAddress可以使用平台之外的第三方解析器。这为开发者提供了更多的灵活性，可以根据具体需求选择更适合的地址解析方式。例如，开发者可以实现自己的地址解析服务提供者，然后通过系统属性或服务加载机制来使用它：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 自定义地址解析器

public class CustomInetAddressResolver implements InetAddressResolver &#123;

       @Override

       public InetAddress\[] lookupAllHostAddr(String host) throws UnknownHostException &#123;

           &#x2F;&#x2F; 自定义解析逻辑

           return new InetAddress\[0];

       &#125;

&#125;

&#x2F;&#x2F; 使用自定义地址解析器

System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);

System.setProperty(&quot;java.net.inetaddress.resolver&quot;, &quot;com.example.CustomInetAddressResolver&quot;);

InetAddress address &#x3D; InetAddress.getByName(&quot;www.example.com&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过这种方式，开发者可以根据应用的特殊需求，定制化地址解析过程，提高网络通信的效率和可靠性。</p>
<h3 id="外部函数和内存-API（第二次孵化）"><a href="#外部函数和内存-API（第二次孵化）" class="headerlink" title="外部函数和内存 API（第二次孵化）"></a>外部函数和内存 API（第二次孵化）</h3><p>JDK 18 对 JDK 14 和 JDK 15 引入的外部函数和内存 API 进行了第二次孵化，通过该 API，Java 程序可以与 Java 运行时之外的代码和数据进行交互，有效调用外部函数（即 JVM 之外的代码），并安全地访问外部内存（JVM 之外的内存）。这使得 Java 程序能够调用本机库并处理本机数据，而无需担心 JNI（Java Native Interface）的脆弱性和危险。例如，调用 C 语言的printf函数：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.foreign.\*;

import java.lang.invoke.MethodHandle;

public class ForeignFunctionCallExample &#123;

       public static void main(String\[] args) throws Throwable &#123;

           LibraryLookup lookup &#x3D; LibraryLookup.ofDefault();

           Symbol printf &#x3D; lookup.lookup(&quot;printf&quot;).orElseThrow();

           MethodHandle handle &#x3D; MethodHandle.ofFunction(printf, MemoryLayout.ofSequence(8, MemoryLayout.JAVA\_BYTE));

           handle.invokeExact(MemoryAddress.NULL, &quot;Hello, %s!\n&quot;, MemoryAddress.ofCString(&quot;world&quot;));

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过外部函数和内存 API，Java 程序成功调用了 C 语言的printf函数，实现了与外部代码的交互，为 Java 开发者提供了更强大的功能和更广阔的应用场景。</p>
<h3 id="switch-模式匹配（第二次预览）"><a href="#switch-模式匹配（第二次预览）" class="headerlink" title="switch 模式匹配（第二次预览）"></a>switch 模式匹配（第二次预览）</h3><p>JDK 18 继续预览了switch的模式匹配功能，将模式匹配扩展到switch，允许针对多个模式测试表达式，每个模式都有特定的操作，使switch语句更加强大和灵活，特别是在处理复杂数据类型时。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; 10;

String result &#x3D; switch (obj) &#123;

       case Integer i -&gt; String.format(&quot;int %d&quot;, i);

       case Long l -&gt; String.format(&quot;long %d&quot;, l);

       case Double d -&gt; String.format(&quot;double %f&quot;, d);

       case String s -&gt; String.format(&quot;String %s&quot;, s);

       default -&gt; obj.toString();

&#125;;

System.out.println(result); &#x2F;&#x2F; 输出: int 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，switch根据obj的类型进行不同的处理，无需进行显式的类型判断和转换，代码更加简洁直观，减少了繁琐的if-else语句嵌套，提高了代码的可读性和可维护性。</p>
<h3 id="弃用-Finalization"><a href="#弃用-Finalization" class="headerlink" title="弃用 Finalization"></a>弃用 Finalization</h3><p>在 Java 1.0 中引入的Finalization旨在帮助避免资源泄漏问题，但由于其存在延迟不可预测、行为不受约束以及线程无法指定等缺陷，导致在安全性、性能、可靠性和可维护性方面都存在问题。因此，JDK 18 将其弃用，建议开发者迁移到其他资源管理技术，例如try-with-resources或Cleaner机制。例如，使用try-with-resources来管理资源：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 使用try-with-resources代替finalization

try (AutoCloseable resource &#x3D; () -&gt; System.out.println(&quot;Resource closed&quot;)) &#123;

       &#x2F;&#x2F; 使用资源

&#125; catch (Exception e) &#123;

       e.printStackTrace();

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过这种方式，资源的关闭由try-with-resources语句自动管理，确保资源在使用完毕后及时释放，避免了资源泄漏和潜在的内存问题。</p>
<p>JDK 18 的这些新特性虽然不是革命性的，但在多个方面都对 Java 进行了优化和扩展，为开发者提供了更高效、更灵活的开发工具和编程方式，推动了 Java 语言的持续发展。</p>
<hr>
<h2 id="JDK-19"><a href="#JDK-19" class="headerlink" title="JDK 19"></a>JDK 19</h2><p>JDK 19 于 2022 年 9 月发布，虽然不是长期支持版本，但它引入的新特性为 Java 开发带来了新的思路和能力，尤其是在并发编程和语言特性的进一步探索上。</p>
<h3 id="虚拟线程（预览）"><a href="#虚拟线程（预览）" class="headerlink" title="虚拟线程（预览）"></a>虚拟线程（预览）</h3><p>虚拟线程是 JDK 19 的一大亮点，它是一种轻量级线程，旨在简化高吞吐量并发应用程序的开发。虚拟线程大大减少了编写、维护和观察高吞吐量并发应用程序的工作量，让开发者可以轻松创建和管理大量并发线程，而无需担心线程创建和上下文切换的高昂开销。例如，使用虚拟线程实现一个简单的并发任务：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;

public class VirtualThreadsExample &#123;

       public static void main(String\[] args) &#123;

           ExecutorService executor &#x3D; Executors.newVirtualThreadPerTaskExecutor();

           for (int i &#x3D; 0; i &lt; 10000; i++) &#123;

               int taskNumber &#x3D; i;

               executor.submit(() -&gt; &#123;

                   System.out.println(&quot;Task &quot; + taskNumber + &quot; is running on &quot; + Thread.currentThread());

                   &#x2F;&#x2F; 模拟任务执行

                   try &#123;

                       Thread.sleep(100);

                   &#125; catch (InterruptedException e) &#123;

                       Thread.currentThread().interrupt();

                   &#125;

               &#125;);

           &#125;

           executor.shutdown();

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过Executors.newVirtualThreadPerTaskExecutor()创建了一个虚拟线程执行器，然后提交了 10000 个任务，每个任务在虚拟线程中执行。使用虚拟线程，开发者可以像使用标准Thread类一样创建和管理线程，但无需担心线程创建和上下文切换的开销，从而提高了应用程序的并发性能和可扩展性。在高并发的 Web 服务器场景中，每个请求可以分配一个虚拟线程进行处理，这样可以轻松应对大量用户的并发请求，而不会因为线程资源耗尽或上下文切换开销过大导致系统性能下降。</p>
<h3 id="结构化并发（孵化）"><a href="#结构化并发（孵化）" class="headerlink" title="结构化并发（孵化）"></a>结构化并发（孵化）</h3><p>结构化并发是 JDK 19 引入的另一个重要特性，它将在不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。例如，使用结构化并发处理多个相关任务：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ExecutionException;

import java.util.concurrent.StructuredTaskScope;

public class StructuredConcurrencyExample &#123;

       public static void main(String\[] args) throws InterruptedException, ExecutionException &#123;

           try (var scope &#x3D; new StructuredTaskScope.ShutdownOnFailure()) &#123;

               var task1 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 任务1的执行逻辑

                   return &quot;Result of task 1&quot;;

               &#125;);

               var task2 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 任务2的执行逻辑

                   return &quot;Result of task 2&quot;;

               &#125;);

               scope.join(); &#x2F;&#x2F; 等待所有任务完成

               scope.throwIfFailed(); &#x2F;&#x2F; 如果有任务失败，抛出异常

               String result1 &#x3D; task1.resultNow();

               String result2 &#x3D; task2.resultNow();

               System.out.println(&quot;Task 1 result: &quot; + result1);

               System.out.println(&quot;Task 2 result: &quot; + result2);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过StructuredTaskScope创建了一个结构化任务作用域，在这个作用域内启动了两个任务task1和task2。scope.join()等待所有任务完成，scope.throwIfFailed()在有任务失败时抛出异常，确保了任务组的一致性和可靠性。在一个涉及多个子任务的复杂业务场景中，如订单处理系统中，一个订单的处理可能涉及多个子任务，如库存检查、支付处理、物流信息更新等，使用结构化并发可以清晰地定义这些子任务之间的关系，当某个子任务失败时，整个订单处理任务组能够及时响应并进行相应的处理，避免资源浪费和潜在的错误。</p>
<h3 id="Record-模式（预览）"><a href="#Record-模式（预览）" class="headerlink" title="Record 模式（预览）"></a>Record 模式（预览）</h3><p>Record 模式是 JDK 19 的一个预览特性，它增强了 Java 编程语言以解构 Record 值。可以嵌套 Record 模式和 Type 模式，以实现强大的、声明性的和可组合的数据导航和处理形式。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">record Point(int x, int y) &#123;&#125;

public class RecordPatternExample &#123;

       public static void main(String\[] args) &#123;

           Point point &#x3D; new Point(10, 20);

           if (point instanceof Point(int x, int y)) &#123;

               System.out.println(&quot;x + y &#x3D; &quot; + (x + y));

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过instanceof结合 Record 模式，直接解构Point对象，获取其内部的x和y值，使代码更加简洁和直观。在处理复杂数据结构时，Record 模式可以方便地提取数据，减少繁琐的访问器方法调用，提高代码的可读性和开发效率。</p>
<h3 id="Switch-模式匹配（第三次预览）"><a href="#Switch-模式匹配（第三次预览）" class="headerlink" title="Switch 模式匹配（第三次预览）"></a>Switch 模式匹配（第三次预览）</h3><p>JDK 19 继续对switch模式匹配进行预览，进一步完善和扩展了这一特性，允许switch表达式和语句针对多种模式进行测试，使代码更加简洁和灵活。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; &quot;Hello, Java 19&quot;;

switch (obj) &#123;

       case String s when s.length() &gt; 10 -&gt; System.out.println(&quot;Long string: &quot; + s);

       case String s -&gt; System.out.println(&quot;Short string: &quot; + s);

       default -&gt; System.out.println(&quot;Not a string&quot;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，switch根据obj的类型和字符串长度进行不同的处理，使用模式匹配和守卫条件，使代码逻辑更加清晰，减少了繁琐的if - else语句嵌套，提高了代码的可读性和可维护性。</p>
<h3 id="外部函数和内存-API（预览）"><a href="#外部函数和内存-API（预览）" class="headerlink" title="外部函数和内存 API（预览）"></a>外部函数和内存 API（预览）</h3><p>JDK 19 对外部函数和内存 API 进行了预览，该 API 允许 Java 程序与 Java 运行时之外的代码和数据进行交互，通过有效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不由 JVM 管理的内存），使 Java 程序能够调用本地库和处理本地数据，而没有 Java 本地接口（JNI）的危险和脆性。例如，调用 C 语言的printf函数：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.foreign.\*;

import java.lang.invoke.MethodHandle;

public class ForeignFunctionAndMemoryAPIDemo &#123;

       public static void main(String\[] args) throws Throwable &#123;

           LibraryLookup lookup &#x3D; LibraryLookup.ofDefault();

           Symbol printf &#x3D; lookup.lookup(&quot;printf&quot;).orElseThrow();

           MethodHandle handle &#x3D; MethodHandle.ofFunction(printf, MemoryLayout.ofSequence(8, MemoryLayout.JAVA\_BYTE));

           handle.invokeExact(MemoryAddress.NULL, &quot;Hello, %s!\n&quot;, MemoryAddress.ofCString(&quot;world&quot;));

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过外部函数和内存 API，Java 程序成功调用了 C 语言的printf函数，实现了与外部代码的交互，为 Java 开发者提供了更强大的功能和更广阔的应用场景，在需要与现有的 C 或 C++ 代码库进行集成，或者需要直接访问底层硬件资源的应用程序中非常有用。</p>
<h3 id="向量-API（第四次孵化）"><a href="#向量-API（第四次孵化）" class="headerlink" title="向量 API（第四次孵化）"></a>向量 API（第四次孵化）</h3><p>向量 API 在 JDK 19 中进行了第四次孵化，它旨在利用现代处理器的 SIMD（Single Instruction, Multiple Data）指令集，实现高效的向量化计算，提高数值计算的性能。向量 API 适用于科学计算、图像处理、机器学习等领域，其中涉及大量的数值计算和数据处理。例如，使用向量 API 进行浮点数向量加法：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.vector.FloatVector;

import jdk.incubator.vector.VectorSpecies;

public class VectorAdditionExample &#123;

       public static void main(String\[] args) &#123;

           VectorSpecies\&lt;Float&gt; species &#x3D; FloatVector.SPECIES\_256;

           float\[] a &#x3D; &#123;1.0f, 2.0f, 3.0f, 4.0f&#125;;

           float\[] b &#x3D; &#123;5.0f, 6.0f, 7.0f, 8.0f&#125;;

           FloatVector va &#x3D; FloatVector.fromArray(species, a, 0);

           FloatVector vb &#x3D; FloatVector.fromArray(species, b, 0);

           FloatVector vc &#x3D; va.add(vb);

           float\[] result &#x3D; new float\[4];

           vc.intoArray(result, 0);

           for (float value : result) &#123;

               System.out.println(value);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码展示了如何使用向量 API 创建浮点数向量，并进行加法操作，与传统的逐个元素计算方式相比，使用向量 API 可以充分利用硬件的并行处理能力，显著提高计算效率，在处理大规模数据和复杂算法时，能有效提升应用程序的性能。</p>
<p>JDK 19 的这些新特性虽然大多还处于预览或孵化阶段，但它们展示了 Java 在并发编程、语言特性和与外部交互等方面的探索和创新，为 Java 的未来发展奠定了基础，值得开发者关注和尝试。</p>
<hr>
<h2 id="JDK-20"><a href="#JDK-20" class="headerlink" title="JDK 20"></a>JDK 20</h2><p>JDK 20 于 2023 年 3 月发布，虽然是一个短期支持版本，但依然带来了一些令人期待的新特性，这些特性聚焦于并发编程、语言增强和与外部交互等方面，为 Java 开发者提供了更多的工具和思路。</p>
<h3 id="作用域值（Scoped-Values，第一次孵化）"><a href="#作用域值（Scoped-Values，第一次孵化）" class="headerlink" title="作用域值（Scoped Values，第一次孵化）"></a>作用域值（Scoped Values，第一次孵化）</h3><p>作用域值是一个孵化中的 API，它提供了一种在多个线程之间共享不可变数据的机制，相比传统的ThreadLocal，它在使用大量虚拟线程时更具优势。ThreadLocal在处理复杂并发场景时存在一些局限性，例如在父子线程传递数据时需要特殊处理，而作用域值可以更方便地在不同线程间传递数据。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.concurrent.ScopedValue;

public class ScopedValueExample &#123;

       private static final ScopedValue\&lt;Integer&gt; SCOPED\_VALUE &#x3D; ScopedValue.newInstance();

       public static void main(String\[] args) &#123;

           ScopedValue.where(SCOPED\_VALUE, 42)

                 .run(() -&gt; &#123;

                       System.out.println(&quot;Inside runnable: &quot; + SCOPED\_VALUE.get());

                   &#125;);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过ScopedValue.where(SCOPED_VALUE, 42).run(…)设置了作用域值，并在内部的runnable中通过SCOPED_VALUE.get()获取该值。作用域值使得在复杂的并发场景中，数据的共享和传递更加安全和便捷，特别是在虚拟线程的环境下，能有效提升并发编程的效率和可读性。</p>
<h3 id="记录模式（Record-Patterns，第二次预览）"><a href="#记录模式（Record-Patterns，第二次预览）" class="headerlink" title="记录模式（Record Patterns，第二次预览）"></a>记录模式（Record Patterns，第二次预览）</h3><p>记录模式可对record的值进行解构，它可以与类型模式嵌套使用，以实现强大、声明性和可组合的数据导航和处理方式。在 JDK 20 中，记录模式的第二次预览增加了对通用记录模式类型参数推断的支持，支持记录模式出现在增强的for语句的头中，并取消了对命名记录模式的支持。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">record Point(int x, int y) &#123;&#125;

public class RecordPatternExample &#123;

       public static void main(String\[] args) &#123;

           Point point &#x3D; new Point(10, 20);

           if (point instanceof Point(int x, int y)) &#123;

               System.out.println(&quot;x + y &#x3D; &quot; + (x + y));

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，通过instanceof结合记录模式，直接解构Point对象，获取其内部的x和y值，避免了繁琐的访问器方法调用，使代码更加简洁直观。在处理复杂数据结构时，记录模式能够更方便地提取和处理数据，提高代码的开发效率和可读性。</p>
<h3 id="switch-模式匹配（第四次预览）"><a href="#switch-模式匹配（第四次预览）" class="headerlink" title="switch 模式匹配（第四次预览）"></a>switch 模式匹配（第四次预览）</h3><p>switch模式匹配在 JDK 20 中进行了第四次预览，进一步完善了该特性。它允许switch表达式和语句针对多种模式进行测试，结合守卫条件，使代码更加灵活和强大。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; &quot;Hello, Java 20&quot;;

switch (obj) &#123;

       case String s when s.length() &gt; 10 -&gt; System.out.println(&quot;Long string: &quot; + s);

       case String s -&gt; System.out.println(&quot;Short string: &quot; + s);

       default -&gt; System.out.println(&quot;Not a string&quot;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，switch根据obj的类型和字符串长度进行不同的处理，使用模式匹配和守卫条件，减少了繁琐的if - else语句嵌套，使代码逻辑更加清晰，提高了代码的可读性和可维护性。</p>
<h3 id="外部函数和内存-API（第二次预览）"><a href="#外部函数和内存-API（第二次预览）" class="headerlink" title="外部函数和内存 API（第二次预览）"></a>外部函数和内存 API（第二次预览）</h3><p>该 API 允许 Java 程序与 Java 运行时之外的代码和数据进行交互，通过有效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不由 JVM 管理的内存），使 Java 程序能够调用本地库和处理本地数据，而没有 Java 本地接口（JNI）的危险和脆性。在 JDK 20 中，第二次预览对MemorySegment和MemoryAddress抽象进行了统一，增强了MemoryLayout层次结构，并且将MemorySession拆分为Arena和SegmentScope，以促进跨维护边界的段共享。例如，调用 C 语言的printf函数：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.foreign.\*;

import java.lang.invoke.MethodHandle;

public class ForeignFunctionAndMemoryAPIDemo &#123;

       public static void main(String\[] args) throws Throwable &#123;

           LibraryLookup lookup &#x3D; LibraryLookup.ofDefault();

           Symbol printf &#x3D; lookup.lookup(&quot;printf&quot;).orElseThrow();

           MethodHandle handle &#x3D; MethodHandle.ofFunction(printf, MemoryLayout.ofSequence(8, MemoryLayout.JAVA\_BYTE));

           handle.invokeExact(MemoryAddress.NULL, &quot;Hello, %s!\n&quot;, MemoryAddress.ofCString(&quot;world&quot;));

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，通过外部函数和内存 API，Java 程序成功调用了 C 语言的printf函数，实现了与外部代码的交互，为 Java 开发者提供了更强大的功能和更广阔的应用场景，尤其适用于需要与现有 C 或 C++ 代码库集成，或直接访问底层硬件资源的应用程序。</p>
<h3 id="虚拟线程（第二次预览）"><a href="#虚拟线程（第二次预览）" class="headerlink" title="虚拟线程（第二次预览）"></a>虚拟线程（第二次预览）</h3><p>虚拟线程是 JDK 实现的轻量级线程，它大大减少了编写、维护和观察高吞吐量并发应用程序的工作量。在 JDK 20 的第二次预览中，对虚拟线程进行了一些优化和改进，包括少量的 API 更改，以及对ThreadGroup的降级等。例如，使用虚拟线程实现一个简单的并发任务：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;

public class VirtualThreadsExample &#123;

       public static void main(String\[] args) &#123;

           ExecutorService executor &#x3D; Executors.newVirtualThreadPerTaskExecutor();

           for (int i &#x3D; 0; i &lt; 10000; i++) &#123;

               int taskNumber &#x3D; i;

               executor.submit(() -&gt; &#123;

                   System.out.println(&quot;Task &quot; + taskNumber + &quot; is running on &quot; + Thread.currentThread());

                   &#x2F;&#x2F; 模拟任务执行

                   try &#123;

                       Thread.sleep(100);

                   &#125; catch (InterruptedException e) &#123;

                       Thread.currentThread().interrupt();

                   &#125;

               &#125;);

           &#125;

           executor.shutdown();

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过Executors.newVirtualThreadPerTaskExecutor()创建了一个虚拟线程执行器，然后提交了 10000 个任务，每个任务在虚拟线程中执行。虚拟线程的引入，使得 Java 在处理高并发场景时，能够轻松创建和管理大量并发线程，避免了线程上下文切换的额外耗费，提高了应用程序的并发性能和可扩展性，在高并发的 Web 服务器、大规模数据处理等场景中具有巨大的优势。</p>
<h3 id="结构化并发（第二次孵化）"><a href="#结构化并发（第二次孵化）" class="headerlink" title="结构化并发（第二次孵化）"></a>结构化并发（第二次孵化）</h3><p>结构化并发将在不同线程中运行的多个任务视为单个工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。在 JDK 20 的第二次孵化中，StructuredTaskScope被更新以支持在任务范围内创建的线程对范围值的继承。例如，使用结构化并发处理多个相关任务：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ExecutionException;

import java.util.concurrent.StructuredTaskScope;

public class StructuredConcurrencyExample &#123;

       public static void main(String\[] args) throws InterruptedException, ExecutionException &#123;

           try (var scope &#x3D; new StructuredTaskScope.ShutdownOnFailure()) &#123;

               var task1 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 任务1的执行逻辑

                   return &quot;Result of task 1&quot;;

               &#125;);

               var task2 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 任务2的执行逻辑

                   return &quot;Result of task 2&quot;;

               &#125;);

               scope.join(); &#x2F;&#x2F; 等待所有任务完成

               scope.throwIfFailed(); &#x2F;&#x2F; 如果有任务失败，抛出异常

               String result1 &#x3D; task1.resultNow();

               String result2 &#x3D; task2.resultNow();

               System.out.println(&quot;Task 1 result: &quot; + result1);

               System.out.println(&quot;Task 2 result: &quot; + result2);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过StructuredTaskScope创建了一个结构化任务作用域，在这个作用域内启动了两个任务task1和task2。scope.join()等待所有任务完成，scope.throwIfFailed()在有任务失败时抛出异常，确保了任务组的一致性和可靠性。在复杂的业务场景中，如订单处理系统中，一个订单的处理可能涉及多个子任务，使用结构化并发可以清晰地定义这些子任务之间的关系，当某个子任务失败时，整个任务组能够及时响应并进行相应的处理，避免资源浪费和潜在的错误。</p>
<h3 id="向量-API（第五次孵化）"><a href="#向量-API（第五次孵化）" class="headerlink" title="向量 API（第五次孵化）"></a>向量 API（第五次孵化）</h3><p>向量 API 用于表示在运行时可靠地编译到支持的 CPU 架构上的最佳矢量硬件指令的矢量计算，旨在提高数值计算的性能。在 JDK 20 中，向量 API 进行了第五次孵化，该实现包括少量的错误修复和性能增强，进一步提升了其在科学计算、图像处理、机器学习等领域的应用能力。例如，使用向量 API 进行浮点数向量加法：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.vector.FloatVector;

import jdk.incubator.vector.VectorSpecies;

public class VectorAdditionExample &#123;

       public static void main(String\[] args) &#123;

           VectorSpecies\&lt;Float&gt; species &#x3D; FloatVector.SPECIES\_256;

           float\[] a &#x3D; &#123;1.0f, 2.0f, 3.0f, 4.0f&#125;;

           float\[] b &#x3D; &#123;5.0f, 6.0f, 7.0f, 8.0f&#125;;

           FloatVector va &#x3D; FloatVector.fromArray(species, a, 0);

           FloatVector vb &#x3D; FloatVector.fromArray(species, b, 0);

           FloatVector vc &#x3D; va.add(vb);

           float\[] result &#x3D; new float\[4];

           vc.intoArray(result, 0);

           for (float value : result) &#123;

               System.out.println(value);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码展示了如何使用向量 API 创建浮点数向量，并进行加法操作，与传统的逐个元素计算方式相比，使用向量 API 可以充分利用硬件的并行处理能力，显著提高计算效率，在处理大规模数据和复杂算法时，能有效提升应用程序的性能。</p>
<p>JDK 20 的这些新特性虽然大多还处于孵化或预览阶段，但它们展示了 Java 在技术创新方面的持续努力，为未来 Java 语言和平台的发展奠定了基础，值得开发者关注和尝试。</p>
<hr>
<h2 id="JDK-21"><a href="#JDK-21" class="headerlink" title="JDK 21"></a>JDK 21</h2><p>JDK 21 于 2023 年 9 月发布，作为长期支持（LTS）版本，带来了一系列重要的特性和改进，进一步提升了 Java 的性能、增强了开发体验，尤其是在并发编程和语言特性方面有了显著的突破，为 Java 开发者带来了更多的便利和创新。</p>
<h3 id="虚拟线程正式发布"><a href="#虚拟线程正式发布" class="headerlink" title="虚拟线程正式发布"></a>虚拟线程正式发布</h3><p>在 JDK 19 和 JDK 20 中预览的虚拟线程在 JDK 21 中正式发布。虚拟线程是一种轻量级线程，由 JVM 调度，大大减少了编写、维护和观察高吞吐量并发应用程序的工作量。它具有极低的创建和上下文切换成本，能够轻松创建和管理数千甚至数百万个并发线程，为开发者提供了一种更高效的并发编程模型。在高并发的 Web 服务器应用中，使用虚拟线程可以显著提高服务器的吞吐量，轻松应对大量用户的并发请求，而不会因为线程创建和管理的开销导致性能下降。例如，使用虚拟线程实现一个简单的并发任务：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;

public class VirtualThreadsExample &#123;

       public static void main(String\[] args) &#123;

           ExecutorService executor &#x3D; Executors.newVirtualThreadPerTaskExecutor();

           for (int i &#x3D; 0; i &lt; 10000; i++) &#123;

               int taskNumber &#x3D; i;

               executor.submit(() -&gt; &#123;

                   System.out.println(&quot;Task &quot; + taskNumber + &quot; is running on &quot; + Thread.currentThread());

                   &#x2F;&#x2F; 模拟任务执行

                   try &#123;

                       Thread.sleep(100);

                   &#125; catch (InterruptedException e) &#123;

                       Thread.currentThread().interrupt();

                   &#125;

               &#125;);

           &#125;

           executor.shutdown();

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过Executors.newVirtualThreadPerTaskExecutor()创建了一个虚拟线程执行器，然后提交了 10000 个任务，每个任务在虚拟线程中执行。使用虚拟线程，开发者可以像使用标准Thread类一样创建和管理线程，但无需担心线程创建和上下文切换的开销，从而提高了应用程序的并发性能和可扩展性。</p>
<h3 id="结构化并发（预览）"><a href="#结构化并发（预览）" class="headerlink" title="结构化并发（预览）"></a>结构化并发（预览）</h3><p>JDK 21 继续对结构化并发进行改进和完善，作为预览特性，它进一步优化了并发编程的体验，使得开发者能够更轻松地编写可靠、高效的并发代码。结构化并发将在不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。例如，使用结构化并发处理多个相关任务：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ExecutionException;

import java.util.concurrent.StructuredTaskScope;

public class StructuredConcurrencyExample &#123;

       public static void main(String\[] args) throws InterruptedException, ExecutionException &#123;

           try (var scope &#x3D; new StructuredTaskScope.ShutdownOnFailure()) &#123;

               var task1 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 任务1的执行逻辑

                   return &quot;Result of task 1&quot;;

               &#125;);

               var task2 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 任务2的执行逻辑

                   return &quot;Result of task 2&quot;;

               &#125;);

               scope.join(); &#x2F;&#x2F; 等待所有任务完成

               scope.throwIfFailed(); &#x2F;&#x2F; 如果有任务失败，抛出异常

               String result1 &#x3D; task1.resultNow();

               String result2 &#x3D; task2.resultNow();

               System.out.println(&quot;Task 1 result: &quot; + result1);

               System.out.println(&quot;Task 2 result: &quot; + result2);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过StructuredTaskScope创建了一个结构化任务作用域，在这个作用域内启动了两个任务task1和task2。scope.join()等待所有任务完成，scope.throwIfFailed()在有任务失败时抛出异常，确保了任务组的一致性和可靠性。在一个涉及多个子任务的复杂业务场景中，如订单处理系统中，一个订单的处理可能涉及多个子任务，如库存检查、支付处理、物流信息更新等，使用结构化并发可以清晰地定义这些子任务之间的关系，当某个子任务失败时，整个任务组能够及时响应并进行相应的处理，避免资源浪费和潜在的错误。</p>
<h3 id="向量-API（第六次孵化）"><a href="#向量-API（第六次孵化）" class="headerlink" title="向量 API（第六次孵化）"></a>向量 API（第六次孵化）</h3><p>Vector API 旨在提供一种简单且高效的方式来执行向量化计算，通过引入新的类和接口，支持使用 SIMD（Single Instruction, Multiple Data）指令集进行并行计算，从而提高在 CPU 向量单元上的性能，特别适用于数值计算密集型应用，如机器学习、图像处理、科学计算等领域。例如，使用 Vector API 进行简单的向量加法：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.vector.FloatVector;

public class VectorAPIExample &#123;

       public static void main(String\[] args) &#123;

           int size &#x3D; 8;

           FloatVector a &#x3D; FloatVector.broadcast(size, 2.0f);

           FloatVector b &#x3D; FloatVector.broadcast(size, 3.0f);

           FloatVector result &#x3D; a.add(b);

           float\[] array &#x3D; new float\[size];

           result.intoArray(array, 0);

           for (float value : array) &#123;

               System.out.println(value);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，创建了两个长度为 8 的浮点数向量a和b，并使用add方法进行向量化加法操作，最后将结果输出。Vector API 的使用，使得开发者可以更方便地利用硬件的并行计算能力，提升应用程序的性能。在机器学习算法中，经常需要进行大量的矩阵运算和向量操作，使用 Vector API 可以显著提高计算效率，加快模型的训练和推理速度。</p>
<h3 id="字符串模板（预览）"><a href="#字符串模板（预览）" class="headerlink" title="字符串模板（预览）"></a>字符串模板（预览）</h3><p>JDK 21 引入了字符串模板（String Templates）的预览特性，它允许在字符串中嵌入表达式，从而实现更灵活和直观的字符串构建。字符串模板使用STR字面量来定义，其中的表达式会在运行时被求值并替换。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">String name &#x3D; &quot;Alice&quot;;

int age &#x3D; 30;

String message &#x3D; STR.&quot;Hello, &#123;name&#125;! You are &#123;age&#125; years old.&quot;;

System.out.println(message); &#x2F;&#x2F; 输出: Hello, Alice! You are 30 years old.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，STR.”Hello, {name}! You are {age} years old.”定义了一个字符串模板，其中{name}和{age}是表达式，会被name和age变量的值替换。字符串模板的引入，使得字符串的构建更加简洁和易读，避免了繁琐的字符串拼接操作，提高了代码的可读性和维护性。在生成动态文本、日志记录、错误消息等场景中，字符串模板都能发挥重要作用。</p>
<h3 id="垃圾回收器的优化"><a href="#垃圾回收器的优化" class="headerlink" title="垃圾回收器的优化"></a>垃圾回收器的优化</h3><p>JDK 21 对垃圾回收器进行了进一步的优化，包括 ZGC 和 G1 垃圾回收器。ZGC 在处理大内存堆时，进一步降低了停顿时间，提高了应用程序的响应性；G1 垃圾回收器在并发标记和混合回收阶段也有性能提升，使得应用在高负载下能够更高效地运行。在一个大内存的电商平台后端服务中，大量的订单数据和用户会话信息需要频繁地进行内存分配和回收，ZGC 和 G1 垃圾回收器的优化可以确保系统在高并发情况下，仍能快速响应用户请求，减少因垃圾回收导致的服务停顿。</p>
<pre class="line-numbers language-none"><code class="language-none">\# 使用ZGC启动Java应用

java -XX:+UseZGC -Xmx4g MyApp

\# 使用G1启动Java应用

java -XX:+UseG1GC -Xmx4g MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上述命令，可以分别启用 ZGC 和 G1 垃圾回收器，并设置最大堆内存为 4GB，开发者可以根据应用的实际需求选择合适的垃圾回收器。</p>
<p>JDK 21 的这些新特性为 Java 开发者带来了更多的选择和更强大的功能，无论是在高并发编程、数值计算还是字符串处理等方面，都提供了更高效、更便捷的解决方案。随着 JDK 21 的发布，Java 在性能和开发体验上又迈出了重要的一步，相信会对 Java 生态系统产生积极的影响，推动 Java 应用的进一步发展。</p>
<hr>
<h2 id="JDK-22"><a href="#JDK-22" class="headerlink" title="JDK 22"></a>JDK 22</h2><p>JDK 22 作为 Java 发展历程中的重要版本，于 2024 年 3 月发布，为 Java 开发者带来了一系列令人瞩目的新特性和改进，进一步提升了 Java 语言的功能和性能，使其在现代软件开发中更具竞争力。</p>
<h3 id="序列模式（预览）"><a href="#序列模式（预览）" class="headerlink" title="序列模式（预览）"></a>序列模式（预览）</h3><p>JDK 22 引入的序列模式（Sequence Patterns）是一项极具创新性的特性，它允许开发者以更灵活、强大的方式匹配和处理序列数据，无论是数组、集合还是流。这一特性在数据处理和算法实现中具有广泛的应用场景，极大地简化了对序列数据的操作。</p>
<p>例如，在处理一个整数数组时，我们可以使用序列模式来查找特定的子序列：</p>
<pre class="line-numbers language-none"><code class="language-none">int\[] numbers &#x3D; &#123;1, 2, 3, 4, 5&#125;;

if (numbers instanceof int\[] &#123;1, 2, 3, \_, \_&#125;) &#123;

       System.out.println(&quot;The array contains the sequence 1, 2, 3&quot;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，int[] {1, 2, 3, _, _}是一个序列模式，其中_表示通配符，可以匹配任意整数。通过这种方式，我们可以简洁地判断数组中是否包含特定的子序列，而无需编写繁琐的循环和条件判断。</p>
<h3 id="增强的-switch-模式匹配（预览）"><a href="#增强的-switch-模式匹配（预览）" class="headerlink" title="增强的 switch 模式匹配（预览）"></a>增强的 switch 模式匹配（预览）</h3><p>JDK 22 对 switch 模式匹配进行了显著增强，使其在处理复杂数据类型和逻辑时更加灵活和强大。新的特性允许在 switch 语句中使用更丰富的模式匹配，结合守卫条件和表达式，使代码逻辑更加清晰和简洁。</p>
<p>例如，当处理一个包含不同图形对象的集合时，可以使用增强的 switch 模式匹配来根据图形类型进行不同的操作：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.List;

record Circle(int radius) &#123;&#125;

record Rectangle(int width, int height) &#123;&#125;

List\&lt;Object&gt; shapes &#x3D; List.of(new Circle(5), new Rectangle(10, 20));

for (Object shape : shapes) &#123;

       switch (shape) &#123;

           case Circle(int radius) when radius &gt; 10 -&gt; System.out.println(&quot;Large circle with radius: &quot; + radius);

           case Circle(int radius) -&gt; System.out.println(&quot;Small circle with radius: &quot; + radius);

           case Rectangle(int width, int height) when width &#x3D;&#x3D; height -&gt; System.out.println(&quot;Square with side length: &quot; + width);

           case Rectangle(int width, int height) -&gt; System.out.println(&quot;Rectangle with width: &quot; + width + &quot;, height: &quot; + height);

           default -&gt; System.out.println(&quot;Unknown shape&quot;);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，switch 语句根据对象的类型和属性值进行不同的处理，通过模式匹配和守卫条件，使代码能够清晰地表达复杂的逻辑，减少了冗长的if - else语句嵌套，提高了代码的可读性和可维护性。</p>
<h3 id="类文件-API（预览）"><a href="#类文件-API（预览）" class="headerlink" title="类文件 API（预览）"></a>类文件 API（预览）</h3><p>类文件 API 是 JDK 22 的一个重要特性，它提供了一种标准化的方式来解析、生成和转换 Java 类文件。这一 API 的引入，使得开发者可以更方便地操作类文件，而无需依赖第三方库，如 ASM。它为 Java 字节码层面的编程和工具开发提供了强大的支持，有助于提高代码的可维护性和安全性。</p>
<p>例如，使用类文件 API 来读取和打印类文件的基本信息：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.classfile.ClassFile;

import jdk.classfile.ClassModel;

import java.io.IOException;

import java.nio.file.Files;

import java.nio.file.Paths;

public class ClassFileAPIDemo &#123;

       public static void main(String\[] args) throws IOException &#123;

           byte\[] classBytes &#x3D; Files.readAllBytes(Paths.get(&quot;MyClass.class&quot;));

           ClassFile classFile &#x3D; ClassFile.of();

           ClassModel classModel &#x3D; classFile.parse(classBytes);

           System.out.println(&quot;Class name: &quot; + classModel.thisClass().asSymbol());

           System.out.println(&quot;Superclass name: &quot; + classModel.superclass().asSymbol());

           classModel.interfaces().forEach(interfaceSymbol -&gt; System.out.println(&quot;Interface: &quot; + interfaceSymbol));

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，通过类文件 API 读取了MyClass.class文件的字节数组，并解析为ClassModel对象，然后打印出类名、超类名和实现的接口，展示了类文件 API 在读取类文件信息方面的便捷性。开发者可以利用这一 API 实现更复杂的功能，如字节码增强、类文件生成等。</p>
<h3 id="外部函数和内存-API（第三次预览）"><a href="#外部函数和内存-API（第三次预览）" class="headerlink" title="外部函数和内存 API（第三次预览）"></a>外部函数和内存 API（第三次预览）</h3><p>外部函数和内存 API 在 JDK 22 中进行了第三次预览，该 API 允许 Java 程序与 Java 运行时之外的代码和数据进行交互，通过有效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不由 JVM 管理的内存），使 Java 程序能够调用本地库和处理本地数据，而没有 Java 本地接口（JNI）的危险和脆性。</p>
<p>例如，调用 C 语言的strlen函数来计算字符串长度：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.foreign.\*;

import java.lang.invoke.MethodHandle;

public class ForeignFunctionAndMemoryAPIDemo &#123;

       public static void main(String\[] args) throws Throwable &#123;

           LibraryLookup lookup &#x3D; LibraryLookup.ofDefault();

           Symbol strlen &#x3D; lookup.lookup(&quot;strlen&quot;).orElseThrow();

           MethodHandle handle &#x3D; MethodHandle.ofFunction(strlen, MemoryLayout.ofValueBits(64, 0, ByteOrder.LITTLE\_ENDIAN));

           MemorySegment stringSegment &#x3D; MemorySegment.ofArray(&quot;Hello, Java 22&quot;.getBytes());

           long length &#x3D; (long) handle.invokeExact(stringSegment.address());

           System.out.println(&quot;Length of the string: &quot; + length);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过外部函数和内存 API，Java 程序成功调用了 C 语言的strlen函数，实现了与外部代码的交互。这一 API 为 Java 开发者提供了更强大的功能和更广阔的应用场景，尤其适用于需要与现有 C 或 C++ 代码库集成，或直接访问底层硬件资源的应用程序。</p>
<h3 id="结构化并发（第三次孵化）"><a href="#结构化并发（第三次孵化）" class="headerlink" title="结构化并发（第三次孵化）"></a>结构化并发（第三次孵化）</h3><p>结构化并发在 JDK 22 中进行了第三次孵化，它将在不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。这一特性在处理复杂的并发任务时非常有用，例如在分布式系统中，一个操作可能涉及多个子任务，每个子任务在不同的线程中执行，使用结构化并发可以更好地管理这些子任务。</p>
<p>例如，使用结构化并发来处理多个异步任务：</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ExecutionException;

import java.util.concurrent.StructuredTaskScope;

public class StructuredConcurrencyExample &#123;

       public static void main(String\[] args) throws InterruptedException, ExecutionException &#123;

           try (var scope &#x3D; new StructuredTaskScope.ShutdownOnFailure()) &#123;

               var task1 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 模拟任务执行

                   try &#123;

                       Thread.sleep(1000);

                   &#125; catch (InterruptedException e) &#123;

                       Thread.currentThread().interrupt();

                   &#125;

                   return &quot;Task 1 result&quot;;

               &#125;);

               var task2 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 模拟任务执行

                   try &#123;

                       Thread.sleep(2000);

                   &#125; catch (InterruptedException e) &#123;

                       Thread.currentThread().interrupt();

                   &#125;

                   return &quot;Task 2 result&quot;;

               &#125;);

               scope.join();

               scope.throwIfFailed();

               String result1 &#x3D; task1.resultNow();

               String result2 &#x3D; task2.resultNow();

               System.out.println(&quot;Result of task 1: &quot; + result1);

               System.out.println(&quot;Result of task 2: &quot; + result2);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过StructuredTaskScope创建了一个结构化任务作用域，在这个作用域内启动了两个任务task1和task2。scope.join()等待所有任务完成，scope.throwIfFailed()在有任务失败时抛出异常，确保了任务组的一致性和可靠性。结构化并发的不断完善，将为 Java 开发者提供更高效、可靠的并发编程模型。</p>
<h3 id="向量-API（第七次孵化）"><a href="#向量-API（第七次孵化）" class="headerlink" title="向量 API（第七次孵化）"></a>向量 API（第七次孵化）</h3><p>向量 API 在 JDK 22 中进行了第七次孵化，它旨在利用现代处理器的 SIMD（Single Instruction, Multiple Data）指令集，实现高效的向量化计算，提高数值计算的性能。向量 API 在科学计算、图像处理、机器学习等领域具有广泛的应用前景，能够显著提升这些领域应用程序的性能。</p>
<p>例如，使用向量 API 进行矩阵乘法运算：</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.vector.FloatVector;

import jdk.incubator.vector.VectorSpecies;

public class MatrixMultiplicationExample &#123;

       public static void main(String\[] args) &#123;

           int size &#x3D; 8;

           VectorSpecies\&lt;Float&gt; species &#x3D; FloatVector.SPECIES\_256;

           float\[] matrixA &#x3D; new float\[size \* size];

           float\[] matrixB &#x3D; new float\[size \* size];

           float\[] result &#x3D; new float\[size \* size];

           &#x2F;&#x2F; 初始化矩阵A和矩阵B

           for (int i &#x3D; 0; i &lt; size \* size; i++) &#123;

               matrixA\[i] &#x3D; i;

               matrixB\[i] &#x3D; i + 1;

           &#125;

           for (int i &#x3D; 0; i &lt; size; i++) &#123;

               for (int j &#x3D; 0; j &lt; size; j++) &#123;

                   FloatVector sum &#x3D; FloatVector.zero(species);

                   for (int k &#x3D; 0; k &lt; size; k +&#x3D; species.length()) &#123;

                       FloatVector a &#x3D; FloatVector.fromArray(species, matrixA, i \* size + k);

                       FloatVector b &#x3D; FloatVector.fromArray(species, matrixB, k \* size + j);

                       sum &#x3D; sum.add(a.mul(b));

                   &#125;

                   sum.intoArray(result, i \* size + j);

               &#125;

           &#125;

           &#x2F;&#x2F; 打印结果矩阵

           for (int i &#x3D; 0; i &lt; size; i++) &#123;

               for (int j &#x3D; 0; j &lt; size; j++) &#123;

                   System.out.print(result\[i \* size + j] + &quot; &quot;);

               &#125;

               System.out.println();

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过向量 API 实现了矩阵乘法运算，利用向量的并行计算能力，大大提高了计算效率。随着向量 API 的不断发展，它将为 Java 在数值计算领域带来更强大的竞争力。</p>
<p>JDK 22 的这些新特性展示了 Java 在语言特性、编程模型和与外部交互等方面的持续创新和进步，为 Java 开发者提供了更多的工具和选择，有助于推动 Java 在各个领域的应用和发展。</p>
<hr>
<h2 id="JDK-23"><a href="#JDK-23" class="headerlink" title="JDK 23"></a>JDK 23</h2><p>JDK 23 于 2024 年 9 月 17 日发布，作为 JDK 21 之后的第一个非 LTS 版本，它为 Java 开发者带来了一系列令人期待的新特性和改进，涵盖了语言增强、API 优化以及性能提升等多个方面，进一步推动了 Java 技术的发展。</p>
<h3 id="模式、instanceof-和-switch-中的原始类型（预览）"><a href="#模式、instanceof-和-switch-中的原始类型（预览）" class="headerlink" title="模式、instanceof 和 switch 中的原始类型（预览）"></a>模式、instanceof 和 switch 中的原始类型（预览）</h3><p>在 JDK 23 之前，instanceof只支持引用类型，switch表达式和语句的case标签也有一定限制。而 JEP 455 的预览特性则全面支持所有原始类型，包括byte、short、char、int、long、float、double、boolean。这一改进大大增强了 Java 语言在类型判断和条件分支处理上的灵活性。</p>
<pre class="line-numbers language-none"><code class="language-none">int i &#x3D; 10;

&#x2F;&#x2F; 传统写法

if (i &gt;&#x3D; -128 &amp;&amp; i &lt;&#x3D; 127) &#123;

       byte b &#x3D; (byte) i;

       &#x2F;&#x2F; 对b进行操作

&#125;

&#x2F;&#x2F; 使用instanceof改进

if (i instanceof byte b) &#123;

       &#x2F;&#x2F; 对b进行操作

&#125;

long v &#x3D; 1L;

&#x2F;&#x2F; 传统写法

if (v &#x3D;&#x3D; 1L) &#123;

       &#x2F;&#x2F; 执行相关逻辑

&#125; else if (v &#x3D;&#x3D; 2L) &#123;

       &#x2F;&#x2F; 执行相关逻辑

&#125; else if (v &#x3D;&#x3D; 10\_000\_000\_000L) &#123;

       &#x2F;&#x2F; 执行相关逻辑

&#125;

&#x2F;&#x2F; 使用long类型的case标签

switch (v) &#123;

       case 1L:

           &#x2F;&#x2F; 执行相关逻辑

           break;

       case 2L:

           &#x2F;&#x2F; 执行相关逻辑

           break;

       case 10\_000\_000\_000L:

           &#x2F;&#x2F; 执行相关逻辑

           break;

       default:

           &#x2F;&#x2F; 执行默认逻辑

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，instanceof直接对int类型进行判断并转换为byte类型，switch语句则可以直接使用long类型的case标签，代码更加简洁直观，减少了繁琐的类型转换和条件判断代码。</p>
<h3 id="类文件-API（第二轮预览）"><a href="#类文件-API（第二轮预览）" class="headerlink" title="类文件 API（第二轮预览）"></a>类文件 API（第二轮预览）</h3><p>类文件 API 在 JDK 22 进行了第一次预览，JDK 23 中进行了第二轮预览。该 API 的目标是提供一套标准化的工具，用于解析、生成和转换 Java 类文件，从而取代过去对第三方库（如 ASM）在类文件处理上的依赖。这使得 Java 开发者在处理类文件时更加方便，同时也提高了代码的可维护性和安全性。</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.classfile.ClassFile;

import jdk.classfile.ClassModel;

import jdk.classfile.ClassElement;

import jdk.classfile.Symbol;

import jdk.classfile.ClassBuilder;

import jdk.classfile.MethodModel;

&#x2F;&#x2F; 创建一个ClassFile对象，这是操作类文件的入口

ClassFile cf &#x3D; ClassFile.of();

&#x2F;&#x2F; 假设这里有一个字节数组表示的类文件

byte\[] bytes &#x3D; new byte\[0];

&#x2F;&#x2F; 解析字节数组为ClassModel

ClassModel classModel &#x3D; cf.parse(bytes);

&#x2F;&#x2F; 构建新的类文件，移除以&quot;debug&quot;开头的所有方法

byte\[] newBytes &#x3D; cf.build(classModel.thisClass().asSymbol(), classBuilder -&gt; &#123;

       &#x2F;&#x2F; 遍历所有类元素

       for (ClassElement ce : classModel) &#123;

           &#x2F;&#x2F; 判断是否为方法且方法名以&quot;debug&quot;开头

           if (!(ce instanceof MethodModel mm &amp;&amp; mm.methodName().stringValue().startsWith(&quot;debug&quot;))) &#123;

               &#x2F;&#x2F; 添加到新的类文件中

               classBuilder.with(ce);

           &#125;

       &#125;

&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上述代码，可以看到使用类文件 API 可以方便地对类文件进行解析和构建操作，实现对类文件内容的自定义处理，例如移除特定的方法。</p>
<h3 id="Markdown-文档注释"><a href="#Markdown-文档注释" class="headerlink" title="Markdown 文档注释"></a>Markdown 文档注释</h3><p>JDK 23 引入了 Markdown 文档注释，允许在 JavaDoc 文档注释中使用 Markdown 语法。这一改进取代了原本只能使用 HTML 和 JavaDoc 标签的方式，使得文档注释的编写和阅读变得更加轻松。Markdown 语法简洁易读，减少了手动编写 HTML 的繁琐，同时保留了对 HTML 元素和 JavaDoc 标签的支持。这不仅提升了文档注释的可维护性，也为开发者提供了更好的文档编写体验。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;\*\*

    \* \*\*这是一个使用Markdown的文档注释\*\*

    \*  

    \* - 支持列表

    \* - 支持链接 \[百度]\(https:&#x2F;&#x2F;www.baidu.com)

    \*  

    \* 同时也支持HTML元素和JavaDoc标签，比如\&lt;em&gt;斜体\&lt;&#x2F;em&gt;，&#123;@link java.util.List List&#125;

    \*&#x2F;

public class MarkdownDocCommentExample &#123;

       &#x2F;&#x2F; 类的具体实现

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过 Markdown 语法可以轻松地编写富有结构和格式的文档注释，使文档更加清晰易懂，方便其他开发者阅读和理解代码的功能和使用方法。</p>
<h3 id="Vector-API（第八轮孵化）"><a href="#Vector-API（第八轮孵化）" class="headerlink" title="Vector API（第八轮孵化）"></a>Vector API（第八轮孵化）</h3><p>向量 API 旨在利用现代处理器的 SIMD（Single Instruction, Multiple Data）指令集，实现高效的向量化计算，提高数值计算的性能。在 JDK 23 中，向量 API 进行了第八轮孵化，不断完善和优化，以提供更简洁易用且与平台无关的表达范围广泛的向量计算。向量 API 适用于科学计算、图像处理、机器学习等领域，在这些领域中，涉及大量的数值计算和数据处理，使用向量 API 可以显著提高计算效率。</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.vector.FloatVector;

public class VectorAPIExample &#123;

       public static void main(String\[] args) &#123;

           int size &#x3D; 8;

           FloatVector a &#x3D; FloatVector.broadcast(size, 2.0f);

           FloatVector b &#x3D; FloatVector.broadcast(size, 3.0f);

           FloatVector result &#x3D; a.add(b);

           float\[] array &#x3D; new float\[size];

           result.intoArray(array, 0);

           for (float value : array) &#123;

               System.out.println(value);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过向量 API 创建了两个浮点数向量a和b，并进行加法操作，最后将结果输出。与传统的逐个元素计算方式相比，向量 API 利用硬件的并行处理能力，能够大幅提升计算效率，在处理大规模数据和复杂算法时优势明显。</p>
<h3 id="废弃-sun-misc-Unsafe-中的内存访问方法以便于将其移除"><a href="#废弃-sun-misc-Unsafe-中的内存访问方法以便于将其移除" class="headerlink" title="废弃 sun.misc.Unsafe 中的内存访问方法以便于将其移除"></a>废弃 sun.misc.Unsafe 中的内存访问方法以便于将其移除</h3><p>JDK 23 中 JEP 471 将sun.misc.Unsafe中的内存访问方法标记为废弃，以便将来将其移除。sun.misc.Unsafe提供了一些低层次的操作，如直接内存访问、对象实例化和内存屏障等，但这些操作可能会破坏 Java 的安全模型和内存管理机制，并且sun.misc.Unsafe属于内部 API，不保证在不同 JDK 版本中的一致性。废弃这些内存访问方法有助于提高 Java 应用的安全性和可维护性，引导开发者使用更安全、标准的 API 来进行内存操作。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 旧的使用sun.misc.Unsafe进行内存访问的方式

&#x2F;&#x2F; sun.misc.Unsafe unsafe &#x3D; sun.misc.Unsafe.getUnsafe();

&#x2F;&#x2F; long address &#x3D; unsafe.allocateMemory(1024);

&#x2F;&#x2F; 新的使用标准API进行内存操作的方式，例如使用ByteBuffer

import java.nio.ByteBuffer;

ByteBuffer buffer &#x3D; ByteBuffer.allocateDirect(1024);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，展示了从使用sun.misc.Unsafe进行内存分配到使用标准的ByteBuffer进行直接内存分配的转变，通过使用标准 API，开发者可以在保证功能的同时，提高代码的安全性和可移植性。</p>
<h3 id="流收集器（第二轮预览）"><a href="#流收集器（第二轮预览）" class="headerlink" title="流收集器（第二轮预览）"></a>流收集器（第二轮预览）</h3><p>流收集器在 JDK 23 中进行了第二轮预览，旨在提供更强大和灵活的流处理能力。它允许开发者更方便地将流中的元素收集到各种数据结构中，并且支持自定义收集逻辑，从而满足不同场景下的数据处理需求。在数据处理和分析场景中，流收集器可以帮助开发者更高效地处理大量数据。</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.stream.Collectors;

import java.util.stream.Stream;

import java.util.Map;

public class StreamGatherersExample &#123;

       public static void main(String\[] args) &#123;

           Stream\&lt;String&gt; stream &#x3D; Stream.of(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);

           &#x2F;&#x2F; 使用流收集器将流中的元素收集到Map中，键为字符串长度，值为字符串列表

           Map\&lt;Integer, java.util.List\&lt;String&gt;&gt; result &#x3D; stream.collect(Collectors.groupingBy(String::length));

           System.out.println(result);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过Collectors.groupingBy方法将流中的字符串按照长度分组，收集到一个Map中，展示了流收集器在数据分组和收集方面的强大功能，开发者可以根据具体需求定制收集逻辑，实现复杂的数据处理操作。</p>
<h3 id="ZGC：默认的分代模式"><a href="#ZGC：默认的分代模式" class="headerlink" title="ZGC：默认的分代模式"></a>ZGC：默认的分代模式</h3><p>JDK 23 将 ZGC（Z Garbage Collector）的分代模式设置为默认模式。ZGC 是一种可扩展的低延迟垃圾收集器，分代模式通过将堆内存划分为不同的代，针对不同代的对象特点采用不同的垃圾回收策略，从而进一步提高垃圾回收的效率。在大内存堆的应用场景中，分代模式可以更好地管理内存，减少垃圾回收的开销，提高应用程序的性能和响应性。</p>
<pre class="line-numbers language-none"><code class="language-none">\# 启动JVM时使用ZGC分代模式（默认）

java -XX:+UseZGC MyApp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过上述命令启动 Java 应用时，默认启用 ZGC 的分代模式，ZGC 会根据对象的生命周期和访问频率等因素，将对象分配到不同的代中进行管理和回收，从而在保证低延迟的同时，提高垃圾回收的效率，适用于高并发、大内存的应用场景，如电商平台的后端服务、大型数据处理系统等。</p>
<h3 id="模块导入声明（预览）"><a href="#模块导入声明（预览）" class="headerlink" title="模块导入声明（预览）"></a>模块导入声明（预览）</h3><p>模块导入声明是 JDK 23 中的一个预览特性，它为 Java 模块系统带来了更灵活的依赖管理方式。通过模块导入声明，模块可以更精确地控制对其他模块的依赖，提高模块之间的隔离性和安全性。在大型 Java 项目中，模块之间的依赖关系复杂，模块导入声明可以帮助开发者更好地管理这些依赖，确保项目的稳定性和可维护性。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; module-info.java文件

module com.example.myapp &#123;

       &#x2F;&#x2F; 导入模块，并且可以指定导入的包

       requires com.example.dependency;

       imports com.example.dependency.publicapi;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，com.example.myapp模块通过requires声明依赖com.example.dependency模块，通过imports指定导入com.example.dependency.publicapi包，这样可以更细粒度地控制模块之间的依赖关系，避免不必要的依赖，提高模块的独立性和安全性。</p>
<h3 id="隐式声明的类和实例主方法（第三轮预览）"><a href="#隐式声明的类和实例主方法（第三轮预览）" class="headerlink" title="隐式声明的类和实例主方法（第三轮预览）"></a>隐式声明的类和实例主方法（第三轮预览）</h3><p>隐式声明的类和实例主方法在 JDK 23 中进行了第三轮预览，这一特性简化了 Java 程序的编写方式。它允许在没有显式定义类和主方法的情况下，直接编写可执行的代码块，使得代码更加简洁和直观，尤其适用于一些简单的脚本式编程场景或快速原型开发。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 隐式声明的类和实例主方法

public class ImplicitClassAndMainMethodExample &#123;

       public static void main(String\[] args) &#123;

           &#x2F;&#x2F; 这里可以直接编写代码逻辑，无需显式定义类和主方法的繁琐结构

           System.out.println(&quot;Hello, Java 23!&quot;);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，虽然仍然采用传统的类和主方法定义方式，但隐式声明的类和实例主方法特性在一些场景下可以进一步简化代码结构，提高开发效率，例如在编写一些简单的工具脚本或进行快速测试时，开发者可以更专注于业务逻辑的实现，而无需过多关注类和方法的定义。</p>
<h3 id="结构化并发（第三轮预览）"><a href="#结构化并发（第三轮预览）" class="headerlink" title="结构化并发（第三轮预览）"></a>结构化并发（第三轮预览）</h3><p>结构化并发在 JDK 23 中进行了第三轮预览，它将在不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。在复杂的并发编程场景中，结构化并发可以帮助开发者更清晰地组织和管理并发任务，减少并发错误的发生。</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ExecutionException;

import java.util.concurrent.StructuredTaskScope;

public class StructuredConcurrencyExample &#123;

       public static void main(String\[] args) throws InterruptedException, ExecutionException &#123;

           try (var scope &#x3D; new StructuredTaskScope.ShutdownOnFailure()) &#123;

               var task1 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 任务1的执行逻辑

                   return &quot;Result of task 1&quot;;

               &#125;);

               var task2 &#x3D; scope.fork(() -&gt; &#123;

                   &#x2F;&#x2F; 任务2的执行逻辑

                   return &quot;Result of task 2&quot;;

               &#125;);

               scope.join(); &#x2F;&#x2F; 等待所有任务完成

               scope.throwIfFailed(); &#x2F;&#x2F; 如果有任务失败，抛出异常

               String result1 &#x3D; task1.resultNow();

               String result2 &#x3D; task2.resultNow();

               System.out.println(&quot;Task 1 result: &quot; + result1);

               System.out.println(&quot;Task 2 result: &quot; + result2);

           &#125;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过StructuredTaskScope创建了一个结构化任务作用域，在这个作用域内启动了两个任务task1和task2。scope.join()等待所有任务完成，scope.throwIfFailed()在有任务失败时抛出异常，确保了任务组的一致性和可靠性。在实际应用中，如分布式系统中的任务协调、多线程数据处理等场景，结构化并发可以更好地管理并发任务，提高系统的稳定性和可靠性。</p>
<h3 id="作用域值（第三轮预览）"><a href="#作用域值（第三轮预览）" class="headerlink" title="作用域值（第三轮预览）"></a>作用域值（第三轮预览）</h3><p>作用域值是一个孵化中的 API，它提供了一种在多个线程之间共享不可变数据的机制，相比传统的ThreadLocal，它在使用大量虚拟线程时更具优势。在 JDK 23 中，作用域值进行了第三轮预览，不断完善其功能和性能。作用域值使得在复杂的并发场景中，数据的共享和传递更加安全和便捷，特别是在虚拟线程的环境下，能有效提升并发编程的效率和可读性。</p>
<pre class="line-numbers language-none"><code class="language-none">import jdk.incubator.concurrent.ScopedValue;

public class ScopedValueExample &#123;

       private static final ScopedValue\&lt;Integer&gt; SCOPED\_VALUE &#x3D; ScopedValue.newInstance();

       public static void main(String\[] args) &#123;

           ScopedValue.where(SCOPED\_VALUE, 42)

                 .run(() -&gt; &#123;

                       System.out.println(&quot;Inside runnable: &quot; + SCOPED\_VALUE.get());

                   &#125;);

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，通过ScopedValue.where(SCOPED_VALUE, 42).run(…)设置了作用域值，并在内部的runnable中通过SCOPED_VALUE.get()获取该值。在实际应用中，例如在一个多线程的 Web 应用中，不同线程可能需要共享一些上下文信息，如用户身份、请求 ID 等，使用作用域值可以方便地在不同线程间传递这些信息，并且保证信息的一致性和安全性。</p>
<h3 id="灵活的构造函数体（第二轮预览）"><a href="#灵活的构造函数体（第二轮预览）" class="headerlink" title="灵活的构造函数体（第二轮预览）"></a>灵活的构造函数体（第二轮预览）</h3><p>灵活的构造函数体在 JDK 23 中进行了第二轮预览，它允许构造函数体中使用更灵活的语法和控制结构。这一特性使得构造函数的编写更加灵活，能够更好地满足复杂的对象初始化需求。在一些需要复杂初始化逻辑的类中，灵活的构造函数体可以使代码更加清晰和易于维护。</p>
<pre class="line-numbers language-none"><code class="language-none">public class FlexibleConstructorExample &#123;

       private int value;

       &#x2F;&#x2F; 传统构造函数

       public FlexibleConstructorExample(int value) &#123;

           this.value &#x3D; value;

       &#125;

       &#x2F;&#x2F; 使用灵活构造函数体

       public FlexibleConstructorExample() &#123;

           &#x2F;&#x2F; 可以在这里进行复杂的初始化逻辑，例如条件判断、循环等

           int temp &#x3D; calculateValue();

           this.value &#x3D; temp;

       &#125;

       private int calculateValue() &#123;

           &#x2F;&#x2F; 模拟复杂的计算逻辑

           return 10 \* 2;

       &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，展示了传统构造函数和使用灵活构造函数体的构造函数。使用灵活构造函数体，可以在构造函数中进行更复杂的初始化操作，如调用其他方法进行计算、根据条件进行不同的初始化等，使对象的初始化过程更加灵活和可控，提高了代码的可维护性和可扩展性。</p>
<p>JDK 23 的这些新特性涵盖了语言特性、API 增强、性能优化等多个方面，为 Java 开发者带来了更多的工具和选择，有助于提升 Java 应用的开发效率、性能和安全性。虽然部分特性还处于预览或孵化阶段，但它们展示了 Java 技术不断发展和创新的趋势，相信在未来的版本中会得到进一步的完善和应用。</p>
<h3 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h3><p>从 JDK 8 到 JDK 21，每一个版本的发布都像是一次技术的革新之旅，为 Java 开发者带来了前所未有的编程体验和强大的工具 ️</p>
<p>Lambda 表达式、Stream API 等让 Java 在函数式编程领域大放异彩，模块化系统为大型项目的架构设计提供了清晰的思路，而各种垃圾收集器的改进和新特性，如 ZGC、Shenandoah 等，让 Java 应用在内存管理和性能优化方面达到了新的高度。同时，文本块、模式匹配、记录类等语言特性的引入，大大简化了代码编写，提高了代码的可读性和可维护性。</p>
<p>对于开发者而言，持续关注和学习 JDK 的新特性是保持技术竞争力的关键。新特性不仅能提升开发效率，还能让我们以更优雅、高效的方式解决实际问题。在未来，随着 Java 的不断发展，相信会有更多创新的特性出现，为我们的编程之路带来更多的惊喜和可能。让我们一起期待 Java 的下一次飞跃，在技术的浪潮中不断前行</p>
<p>#你在 JDK 的使用中最喜欢哪个版本的特性呢？欢迎在评论区分享你的经验和见解。#</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://alei.vip">啊雷</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://alei.vip/2025/06/11/Java%E4%BB%8E8%E5%88%B021%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%A0get%E4%BA%86%E5%90%97%EF%BC%9F%E2%9C%A8/">http://alei.vip/2025/06/11/Java%E4%BB%8E8%E5%88%B021%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%A0get%E4%BA%86%E5%90%97%EF%BC%9F%E2%9C%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://alei.vip" target="_blank">指尖留痕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/JDK/">JDK</a><a class="post-meta__tags" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/">新特性</a><a class="post-meta__tags" href="/tags/JDK8/"> JDK8</a></div><div class="post-share"><div class="social-share" data-image="/images/post_img/cover.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/10/hello-world/" title="Hello World"><img class="cover" src="/img/post/post_img_16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post"  More info: Writing Run server$ hexo server  More info: Server Generate static files$ hexo generate  More info: Generating Deploy to remote sites$ hexo deploy  Test Java Codepackage org.jeecg.modules.quartz.job;  import...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">啊雷</div><div class="author-info-description">啊雷 --> 指尖留痕-个人笔记</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/aleivip"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/aleivip" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://gitee.com/aleivip" target="_blank" title="GitEE"><i class="iconfont blog-gitee" style="color: #24292e;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/a-lei-73-1-1" target="_blank" title="知乎"><i class="iconfont blog-zhihu" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:528301299@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-8%EF%BC%9A%E5%BC%80%E5%90%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A4%A7%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">JDK 8：开启函数式编程大门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">Lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-API"><span class="toc-number">1.2.</span> <span class="toc-text">Stream API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional-%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">Optional 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-9-%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%9B%B4%E5%A4%9A%E6%94%B9%E8%BF%9B"><span class="toc-number">2.</span> <span class="toc-text">JDK 9 - 模块化与更多改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F%EF%BC%88Project-Jigsaw%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">模块化系统（Project Jigsaw）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">私有接口方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">集合工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JShell"><span class="toc-number">2.4.</span> <span class="toc-text">JShell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-10-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E6%9D%A5%E8%A2%AD"><span class="toc-number">3.</span> <span class="toc-text">JDK 10 - 局部变量类型推断来袭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">3.1.</span> <span class="toc-text">什么是局部变量类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">var关键字的使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">在实际代码中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-11-%E5%A2%9E%E5%BC%BA%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">JDK 11 - 增强与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.1.</span> <span class="toc-text">HTTP&#x2F;2 客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-API-%E5%A2%9E%E5%BC%BA"><span class="toc-number">4.2.</span> <span class="toc-text">字符串 API 增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Epsilon-%E5%92%8C-ZGC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">Epsilon 和 ZGC 垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">其他特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-12"><span class="toc-number">5.</span> <span class="toc-text">JDK 12</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B9%E8%BF%9B%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">Switch 表达式改进（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E5%B8%B8%E9%87%8F-API"><span class="toc-number">5.2.</span> <span class="toc-text">JVM 常量 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shenandoah-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%AE%9E%E9%AA%8C%E6%80%A7%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">Shenandoah 垃圾收集器（实验性）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-13"><span class="toc-number">6.</span> <span class="toc-text">JDK 13</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%9A%84-CDS-%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">动态的 CDS 归档文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E4%BA%86-ZGC"><span class="toc-number">6.2.</span> <span class="toc-text">改进了 ZGC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E4%BA%86-Socket-API"><span class="toc-number">6.3.</span> <span class="toc-text">重新实现了 Socket API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">Switch 表达式（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">文本块（预览）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-14"><span class="toc-number">7.</span> <span class="toc-text">JDK 14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-for-instanceof%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">模式匹配 for instanceof（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Records%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">Records（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E6%A0%87%E5%87%86%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">Switch 表达式（标准）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">文本块（第二预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84-NullPointerException"><span class="toc-number">7.5.</span> <span class="toc-text">改进的 NullPointerException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9-G1-%E7%9A%84-NUMA-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96"><span class="toc-number">7.6.</span> <span class="toc-text">针对 G1 的 NUMA 内存分配优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JFR-%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">7.7.</span> <span class="toc-text">JFR 事件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4-CMS-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.8.</span> <span class="toc-text">移除 CMS 垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC-%E6%94%AF%E6%8C%81-macOS-%E5%92%8C-Windows-%E5%B9%B3%E5%8F%B0"><span class="toc-number">7.9.</span> <span class="toc-text">ZGC 支持 macOS 和 Windows 平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%83%E7%94%A8-ParallelScavenge-SerialOld-GC-%E7%BB%84%E5%90%88"><span class="toc-number">7.10.</span> <span class="toc-text">弃用 ParallelScavenge + SerialOld GC 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E6%98%A0%E5%B0%84%E7%9A%84%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.11.</span> <span class="toc-text">非易失性映射的字节缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE-API%EF%BC%88%E5%AD%B5%E5%8C%96%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">7.12.</span> <span class="toc-text">外部内存访问 API（孵化阶段）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-15"><span class="toc-number">8.</span> <span class="toc-text">JDK 15</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">密封类（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">隐藏类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">instanceof 模式匹配（第二次预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC-%E8%BD%AC%E6%AD%A3"><span class="toc-number">8.4.</span> <span class="toc-text">ZGC 转正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97%E8%BD%AC%E6%AD%A3"><span class="toc-number">8.5.</span> <span class="toc-text">文本块转正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7-1"><span class="toc-number">8.6.</span> <span class="toc-text">其他特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-16"><span class="toc-number">9.</span> <span class="toc-text">JDK 16</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">9.1.</span> <span class="toc-text">增强的 G1 垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE-API%EF%BC%88%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">外部内存访问 API（第三次孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E8%BD%AC%E6%AD%A3%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">instanceof 模式匹配（转正）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB%EF%BC%88%E6%AD%A3%E5%BC%8F%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">9.4.</span> <span class="toc-text">记录类（正式特性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">9.5.</span> <span class="toc-text">密封类（第二次预览）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-17"><span class="toc-number">10.</span> <span class="toc-text">JDK 17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB%EF%BC%88%E8%BD%AC%E6%AD%A3%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">密封类（转正）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">Switch 表达式的模式匹配（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB%EF%BC%88%E6%AD%A3%E5%BC%8F%E7%89%B9%E6%80%A7%EF%BC%89-1"><span class="toc-number">10.3.</span> <span class="toc-text">记录类（正式特性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">10.4.</span> <span class="toc-text">外部函数和内存 API（孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">10.5.</span> <span class="toc-text">向量 API（第二次孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B"><span class="toc-number">10.6.</span> <span class="toc-text">性能改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E5%A2%9E%E5%BC%BA"><span class="toc-number">10.7.</span> <span class="toc-text">安全性增强</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-18"><span class="toc-number">11.</span> <span class="toc-text">JDK 18</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UTF-8-%E6%88%90%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">11.1.</span> <span class="toc-text">UTF-8 成为默认字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">简单的 Web 服务器（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-API-%E6%96%87%E6%A1%A3%E6%94%AF%E6%8C%81%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5"><span class="toc-number">11.3.</span> <span class="toc-text">Java API 文档支持代码片段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%A0%B8%E5%BF%83%E5%8F%8D%E5%B0%84%EF%BC%88Method-Handles%EF%BC%89"><span class="toc-number">11.4.</span> <span class="toc-text">重新实现核心反射（Method Handles）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-API%EF%BC%88%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">11.5.</span> <span class="toc-text">Vector API（第三次孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90-SPI"><span class="toc-number">11.6.</span> <span class="toc-text">互联网地址解析 SPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">11.7.</span> <span class="toc-text">外部函数和内存 API（第二次孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">11.8.</span> <span class="toc-text">switch 模式匹配（第二次预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%83%E7%94%A8-Finalization"><span class="toc-number">11.9.</span> <span class="toc-text">弃用 Finalization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-19"><span class="toc-number">12.</span> <span class="toc-text">JDK 19</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">虚拟线程（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%EF%BC%88%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">结构化并发（孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Record-%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">Record 模式（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">12.4.</span> <span class="toc-text">Switch 模式匹配（第三次预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">12.5.</span> <span class="toc-text">外部函数和内存 API（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">12.6.</span> <span class="toc-text">向量 API（第四次孵化）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-20"><span class="toc-number">13.</span> <span class="toc-text">JDK 20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%80%BC%EF%BC%88Scoped-Values%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">13.1.</span> <span class="toc-text">作用域值（Scoped Values，第一次孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88Record-Patterns%EF%BC%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">13.2.</span> <span class="toc-text">记录模式（Record Patterns，第二次预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">13.3.</span> <span class="toc-text">switch 模式匹配（第四次预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">13.4.</span> <span class="toc-text">外部函数和内存 API（第二次预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">13.5.</span> <span class="toc-text">虚拟线程（第二次预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">13.6.</span> <span class="toc-text">结构化并发（第二次孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">13.7.</span> <span class="toc-text">向量 API（第五次孵化）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-21"><span class="toc-number">14.</span> <span class="toc-text">JDK 21</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83"><span class="toc-number">14.1.</span> <span class="toc-text">虚拟线程正式发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">14.2.</span> <span class="toc-text">结构化并发（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E5%85%AD%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">14.3.</span> <span class="toc-text">向量 API（第六次孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">14.4.</span> <span class="toc-text">字符串模板（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">14.5.</span> <span class="toc-text">垃圾回收器的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-22"><span class="toc-number">15.</span> <span class="toc-text">JDK 22</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">15.1.</span> <span class="toc-text">序列模式（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84-switch-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">15.2.</span> <span class="toc-text">增强的 switch 模式匹配（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6-API%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">15.3.</span> <span class="toc-text">类文件 API（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">15.4.</span> <span class="toc-text">外部函数和内存 API（第三次预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%EF%BC%88%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">15.5.</span> <span class="toc-text">结构化并发（第三次孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E4%B8%83%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">15.6.</span> <span class="toc-text">向量 API（第七次孵化）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-23"><span class="toc-number">16.</span> <span class="toc-text">JDK 23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E3%80%81instanceof-%E5%92%8C-switch-%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">16.1.</span> <span class="toc-text">模式、instanceof 和 switch 中的原始类型（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6-API%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">16.2.</span> <span class="toc-text">类文件 API（第二轮预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Markdown-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">16.3.</span> <span class="toc-text">Markdown 文档注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-API%EF%BC%88%E7%AC%AC%E5%85%AB%E8%BD%AE%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="toc-number">16.4.</span> <span class="toc-text">Vector API（第八轮孵化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%9F%E5%BC%83-sun-misc-Unsafe-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%E4%BB%A5%E4%BE%BF%E4%BA%8E%E5%B0%86%E5%85%B6%E7%A7%BB%E9%99%A4"><span class="toc-number">16.5.</span> <span class="toc-text">废弃 sun.misc.Unsafe 中的内存访问方法以便于将其移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">16.6.</span> <span class="toc-text">流收集器（第二轮预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC%EF%BC%9A%E9%BB%98%E8%AE%A4%E7%9A%84%E5%88%86%E4%BB%A3%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.7.</span> <span class="toc-text">ZGC：默认的分代模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%A3%B0%E6%98%8E%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">16.8.</span> <span class="toc-text">模块导入声明（预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E4%B8%BB%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%89%E8%BD%AE%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">16.9.</span> <span class="toc-text">隐式声明的类和实例主方法（第三轮预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%EF%BC%88%E7%AC%AC%E4%B8%89%E8%BD%AE%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">16.10.</span> <span class="toc-text">结构化并发（第三轮预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%80%BC%EF%BC%88%E7%AC%AC%E4%B8%89%E8%BD%AE%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">16.11.</span> <span class="toc-text">作用域值（第三轮预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">16.12.</span> <span class="toc-text">灵活的构造函数体（第二轮预览）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="toc-number">16.13.</span> <span class="toc-text">总结与展望</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/11/Java%E4%BB%8E8%E5%88%B021%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%A0get%E4%BA%86%E5%90%97%EF%BC%9F%E2%9C%A8/" title="Java从8到21，这些新特性你get了吗？✨"><img src="/images/post_img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java从8到21，这些新特性你get了吗？✨"/></a><div class="content"><a class="title" href="/2025/06/11/Java%E4%BB%8E8%E5%88%B021%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%A0get%E4%BA%86%E5%90%97%EF%BC%9F%E2%9C%A8/" title="Java从8到21，这些新特性你get了吗？✨">Java从8到21，这些新特性你get了吗？✨</a><time datetime="2025-06-11T01:06:18.000Z" title="发表于 2025-06-11 09:06:18">2025-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/10/hello-world/" title="Hello World"><img src="/img/post/post_img_16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/06/10/hello-world/" title="Hello World">Hello World</a><time datetime="2025-06-10T06:47:19.021Z" title="发表于 2025-06-10 14:47:19">2025-06-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By 啊雷</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>备案号：津ICP备2025034095号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lifwsiSM535EYPql',
      clientSecret: '9c14c6a6b4a4dba46dae2876cf0a9580c9d99fac',
      repo: 'aleivip.github.io',
      owner: 'aleivip',
      admin: ['aleivip'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'f742f75c034eb70c2f95c11545e2409f'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>